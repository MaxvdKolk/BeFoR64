var tipuesearch = {"pages":[{"text":"BeFoR64 BeFoR64 BeFoR64, Base64 encoding/decoding library for FoRtran poor people BeFoR64 is a pure Fortran (KISS) library for base64 encoding/decoding for modern (2003+) Fortran projects; BeFoR64 is Fortran 2003+ standard compliant; BeFoR64 is a Free, Open Source Project. Table of Contents What is BeFoR64? Main features Copyrights Documentation A Taste of BeFoR64 Issues Compiler Support -brightgreen.svg) -brightgreen.svg) What is BeFoR64? Modern Fortran standards (2003+) have introduced better support for strings manipulations. Exploiting such new Fortran capabilities, BeFoR64 provides an easy to use module library for encoding and decoding Fortran types (binary internal representation) in ascii- base64 -encoded string. Go to Top Main features User-friendly methods for encoding/decoding in base64: encode real/integer scalar variables; decode real/integer scalar variables; encode real/integer array variables; decode real/integer array variables; encode character scalar variables; decode character scalar variables; encode character array variables; decode character array variables; encode unlimited polymorphic scalar variables; decode unlimited polymorphic scalar variables; encode unlimited polymorphic array variables; decode unlimited polymorphic array variables; user-friendly methods for packing heterogeneous data: pack integer/integer (different kinds) scalars; pack integer/integer (different kinds) arrays; pack real/real (different kinds) scalars; pack real/real (different kinds) arrays; pack integer/real scalars; pack integer/real arrays; errors trapping mechanism. Any feature request is welcome. Go to Top Copyrights BeFoR64 is an open source project, it is distributed under a multi-licensing system: for FOSS projects: GPL v3 ; for closed source/commercial projects: BSD 2-Clause ; BSD 3-Clause ; MIT . Anyone is interest to use, to develop or to contribute to BeFoR64 is welcome, feel free to select the license that best matches your soul! More details can be found on wiki . Go to Top Documentation Besides this README file the BeFoR64 documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . A Taste of BeFoR64 Let us assume our goal is encoding a binary integer. It is as simple as use befor64 ... character ( len = :), allocatable :: code64 ! base64 encoded string ... call b64_encode ( n = 1 2._R8P , code = code64 ) print \"(A)\" , code64 But you are not limited to a simple integer scalar, you can encode real, integer, characters scalar or arrays, and by means of the auxiliary Lib_Pack library also mixed types. See the wiki . Go to Top Developer Info Stefano Zaghi","tags":"","loc":"index.html","title":" BeFoR64 "},{"text":"BeFoR64, Base64 encoding/decoding library for FoRtran poor people. This File Depends On sourcefile~~befor64.f90~~EfferentGraph sourcefile~befor64.f90 befor64.F90 sourcefile~befor64_pack_data_m.f90 befor64_pack_data_m.F90 sourcefile~befor64_pack_data_m.f90->sourcefile~befor64.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~befor64.f90~~AfferentGraph sourcefile~befor64.f90 befor64.F90 sourcefile~befor64_test.f90 befor64_test.f90 sourcefile~befor64.f90->sourcefile~befor64_test.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules befor64 Source Code befor64.F90 Source Code !< BeFoR64, Base64 encoding/decoding library for FoRtran poor people. module befor64 !----------------------------------------------------------------------------------------------------------------------------------- !< BeFoR64, Base64 encoding/decoding library for FoRtran poor people. !----------------------------------------------------------------------------------------------------------------------------------- use penf ! Portability environment. use befor64_pack_data_m ! Library for packing heterogeneous data into single (homogeneous) packed one. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: is_b64_initialized , b64_init public :: b64_encode , b64_encode_up public :: b64_decode , b64_decode_up public :: pack_data public :: autotest !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- logical :: is_b64_initialized = . false . !< Flag for checking the initialization of the library. character ( 64 ) :: base64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\" !< Base64 alphabet. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface b64_encode !< Encode numbers (integer and real) to base64. !< !< This is an interface for encoding integer and real numbers of any kinds into a base64 string. This interface can encode both !< scalar and array. !< !< @warning The encoded string is returned as varying length character string, `character(len=:), allocatable:: string`, thus the !< compiler must support such a Fortran (2003) feature. !< !< @note Before start to encode anything the library must be initialized. The procedure `b64_init` must be called at first. The !< global variable `is_b64_initialized` can be used to check the status of the initialization. !< !<### Usage !< For a practical example see the `autotest` procedure. !< !<#### Scalar encoding !<```fortran !<character(len=:), allocatable:: code64 ! base64 encoded string !<... !<call b64_encode(n=12._R8P,code=code64) !<``` !< !<#### Array encoding !<```fortran !<character(len=:), allocatable:: code64 ! base64 encoded string !<... !<call b64_encode(n=[12_I4P,1_I4P],code=code64) !<``` !< !< @note If you want to encode heterogenous data (e.g. integer and real numbers), you must use the auxiliary `pack_data` !< procedure. !< !< @warning The encoding of array of strings is admitted only if each string of the array has the same length. module procedure & #ifdef _R16P_SUPPORTED b64_encode_R16 , b64_encode_R16_a , & #endif b64_encode_R8 , b64_encode_R8_a , & b64_encode_R4 , b64_encode_R4_a , & b64_encode_I8 , b64_encode_I8_a , & b64_encode_I4 , b64_encode_I4_a , & b64_encode_I2 , b64_encode_I2_a , & b64_encode_I1 , b64_encode_I1_a , & b64_encode_string , b64_encode_string_a endinterface interface b64_encode_up !< Encode unlimited polymorphic variable to base64. !< !< This is an interface for encoding both scalar and array. !< !< @warning The encoded string is returned as varying length character string, `character(len=:), allocatable:: string`, thus the !< compiler must support such a Fortran (2003) feature. !< !< @note Before start to encode anything the library must be initialized. The procedure `b64_init` must be called at first. The !< global variable `is_b64_initialized` can be used to check the status of the initialization. !< !<### Usage !< For a practical example see the `autotest` procedure. !< !<#### Scalar encoding !<```fortran !<character(len=:), allocatable:: code64 ! base64 encoded string !<... !<call b64_encode_up(up=12._R8P,code=code64) !<``` !< !<#### Array encoding !<```fortran !<character(len=:), allocatable:: code64 ! base64 encoded string !<... !<call b64_encode_up(up=[12_I4P,1_I4P],code=code64) !<``` !< !< @note If you want to encode heterogenous data (e.g. integer and real numbers), you must use the auxiliary `pack_data` !< procedure. !< !< @warning The encoding of array of strings is admitted only if each string of the array has the same length. module procedure b64_encode_up , b64_encode_up_a endinterface interface b64_decode !< Decode numbers (integer and real) from base64. !< !< This is an interface for decoding integer and real numbers of any kinds from a base64 string. This interface can decode both !< scalar and array. !< !< @note Before start to decode anything the library must be initialized. The procedure `b64_init` must be called at first. The !< global variable `is_b64_initialized` can be used to check the status of the initialization. !< !<### Usage !< For a practical example see the `autotest` procedure. !< !<#### Scalar decoding !<```fortran !<real(R8P):: decoded ! scalar to be decoded !<... !<call b64_decode(code='AAAAAAAA8D8=',n=decoded) !<``` !< !<#### Array decoding !<```fortran !<integer(I8P):: decoded(1:4) ! array to be decoded !<... !<call b64_decode(code='FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=',n=decoded) !<``` !< !< @note If you want to decode heterogenous data (e.g. integer and real numbers), you must use the auxiliary `pack_data` !< procedure. !< !< @warning The decoding of array of strings is admitted only if each string of the array has the same length. module procedure & #ifdef _R16P_SUPPORTED b64_decode_R16 , b64_decode_R16_a , & #endif b64_decode_R8 , b64_decode_R8_a , & b64_decode_R4 , b64_decode_R4_a , & b64_decode_I8 , b64_decode_I8_a , & b64_decode_I4 , b64_decode_I4_a , & b64_decode_I2 , b64_decode_I2_a , & b64_decode_I1 , b64_decode_I1_a , & b64_decode_string , b64_decode_string_a endinterface interface b64_decode_up !< Decode unlimited polymorphic variable from base64. !< !< This is an interface for decoding both scalar and array. !< !< @note Before start to decode anything the library must be initialized. The procedure `b64_init` must be called at first. The !< global variable `is_b64_initialized` can be used to check the status of the initialization. !< !<### Usage !< For a practical example see the `autotest` procedure. !< !<#### Scalar decoding !<```fortran !<real(R8P):: decoded ! scalar to be decoded !<... !<call b64_decode_up(code='AAAAAAAA8D8=',up=decoded) !<``` !< !<#### Array decoding !<```fortran !<integer(I8P):: decoded(1:4) ! array to be decoded !<... !<call b64_decode_up(code='FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=',up=decoded) !<``` !< !< @note If you want to decode heterogenous data (e.g. integer and real numbers), you must use the auxiliary `pack_data` !< procedure. !< !< @warning The decoding of array of strings is admitted only if each string of the array has the same length. module procedure b64_decode_up , b64_decode_up_a endinterface contains subroutine b64_init () !< Initialize the BeFoR64 library. !< !< @note This procedure **must** be called before encoding/decoding anything! if (. not . is_initialized ) call penf_init is_b64_initialized = . true . endsubroutine b64_init pure subroutine encode_bits ( bits , padd , code ) !< Encode a bits stream (must be multiple of 24 bits) into base64 charcaters code (of length multiple of 4). !< !< The bits stream are encoded in chunks of 24 bits as the following example (in little endian order) !<``` !< +--first octet--+-second octet--+--third octet--+ !< |7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0| !< +-----------+---+-------+-------+---+-----------+ !< |5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0| !< +--1.index--+--2.index--+--3.index--+--4.index--+ !<``` !< @note The 4 indexes are stored into 4 elements 8 bits array, thus 2 bits of each array element are not used. !< !< @note The number of paddings must be computed outside this procedure, into the calling scope. !< !< @warning This procedure is the backend of encoding, thus it must be never called outside the module. integer ( I1P ), intent ( in ) :: bits ( 1 :) !< Bits to be encoded. integer ( I4P ), intent ( in ) :: padd !< Number of padding characters ('='). character ( * ), intent ( out ) :: code !< Characters code. integer ( I1P ) :: sixb ( 1 : 4 ) !< 6 bits slices (stored into 8 bits integer) of 24 bits input. integer ( I8P ) :: c !< Counter. integer ( I8P ) :: e !< Counter. integer ( I8P ) :: Nb !< Length of bits array. Nb = size ( bits , dim = 1 , kind = I8P ) c = 1_I8P do e = 1_I8P , Nb , 3_I8P ! loop over array elements: 3 bytes (24 bits) scanning sixb = 0_I1P call mvbits ( bits ( e ), 2 , 6 , sixb ( 1 ), 0 ) call mvbits ( bits ( e ), 0 , 2 , sixb ( 2 ), 4 ) if ( e + 1 <= Nb ) then call mvbits ( bits ( e + 1 ), 4 , 4 , sixb ( 2 ), 0 ) call mvbits ( bits ( e + 1 ), 0 , 4 , sixb ( 3 ), 2 ) endif if ( e + 2 <= Nb ) then call mvbits ( bits ( e + 2 ), 6 , 2 , sixb ( 3 ), 0 ) call mvbits ( bits ( e + 2 ), 0 , 6 , sixb ( 4 ), 0 ) endif sixb = sixb + 1_I1P code ( c : c ) = base64 ( sixb ( 1 ): sixb ( 1 )) code ( c + 1 : c + 1 ) = base64 ( sixb ( 2 ): sixb ( 2 )) code ( c + 2 : c + 2 ) = base64 ( sixb ( 3 ): sixb ( 3 )) code ( c + 3 : c + 3 ) = base64 ( sixb ( 4 ): sixb ( 4 )) c = c + 4_I8P enddo if ( padd > 0 ) code ( len ( code ) - padd + 1 :) = repeat ( '=' , padd ) endsubroutine encode_bits pure subroutine decode_bits ( code , bits ) !< Decode a base64 string into a sequence of bits stream. !< !< The base64 string must be parsed with a strike of 4 characters and converted into a 3 bytes stream. Considering the base64 code !< `QUJD` the decoding process must do !<``` !< +-b64 char--+-b64 char--+-b64 char--+-b64 char--+ !< |      Q    |      U    |      J    |      D    | !< +-b64 index-+-b64 index-+-b64 index-+-b64 index-+ !< !      16   |      20   |      9    |      3    | !< +-6 bits----+-6 bits----+-6 bits----+-6 bits----+ !< |0 1 0 0 0 0|0 1 0 1 0 0|0 0 1 0 0 1|0 0 0 0 1 1| !< +-----------+---+-------+-------+---+-----------+ !< |0 1 0 0 0 0 0 1|0 1 0 0 0 0 1 0|0 1 0 0 0 0 1 1| !< +-----8 bits----+-----8 bits----+-----8 bits----+ !<``` !< @note The bits pattern is returned as a 1-byte element array, the dimension of witch must be computed outside this procedure. !< !< @warning This procedure is the backend of decoding, thus it must be never called outside the module. character ( * ), intent ( in ) :: code !< Characters code. integer ( I1P ), intent ( out ) :: bits ( 1 :) !< Bits decoded. integer ( I1P ) :: sixb ( 1 : 4 ) !< 6 bits slices (stored into 8 bits integer) of 24 bits input. integer ( I8P ) :: c !< Counter. integer ( I8P ) :: e !< Counter. integer ( I8P ) :: Nb !< Length of bits array. Nb = size ( bits , dim = 1 , kind = I8P ) e = 1_I8P do c = 1_I8P , len ( code ), 4_I8P ! loop over code characters: 3 bytes (24 bits) scanning sixb = 0_I1P sixb ( 1 ) = index ( base64 , code ( c : c )) - 1 sixb ( 2 ) = index ( base64 , code ( c + 1 : c + 1 )) - 1 sixb ( 3 ) = index ( base64 , code ( c + 2 : c + 2 )) - 1 sixb ( 4 ) = index ( base64 , code ( c + 3 : c + 3 )) - 1 call mvbits ( sixb ( 1 ), 0 , 6 , bits ( e ), 2 ) ; call mvbits ( sixb ( 2 ), 4 , 2 , bits ( e ), 0 ) if ( e + 1 <= Nb ) then call mvbits ( sixb ( 2 ), 0 , 4 , bits ( e + 1 ), 4 ) ; call mvbits ( sixb ( 3 ), 2 , 4 , bits ( e + 1 ), 0 ) endif if ( e + 2 <= Nb ) then call mvbits ( sixb ( 3 ), 0 , 2 , bits ( e + 2 ), 6 ) ; call mvbits ( sixb ( 4 ), 0 , 6 , bits ( e + 2 ), 0 ) endif e = e + 3_I8P enddo endsubroutine decode_bits subroutine b64_encode_up ( up , code ) !< Encode an unlimited polymorphic scalar to base64. class ( * ), intent ( in ) :: up !< Unlimited polymorphic variable to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. select type ( up ) type is ( real ( R8P )) call b64_encode_R8 ( n = up , code = code ) type is ( real ( R4P )) call b64_encode_R4 ( n = up , code = code ) type is ( integer ( I8P )) call b64_encode_I8 ( n = up , code = code ) type is ( integer ( I4P )) call b64_encode_I4 ( n = up , code = code ) type is ( integer ( I2P )) call b64_encode_I2 ( n = up , code = code ) type is ( integer ( I1P )) call b64_encode_I1 ( n = up , code = code ) type is ( character ( * )) call b64_encode_string ( s = up , code = code ) endselect endsubroutine b64_encode_up pure subroutine b64_encode_up_a ( up , code ) !< Encode an unlimited polymorphic array to base64. class ( * ), intent ( in ) :: up ( 1 :) !< Unlimited polymorphic variable to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. select type ( up ) type is ( real ( R8P )) call b64_encode_R8_a ( n = up , code = code ) type is ( real ( R4P )) call b64_encode_R4_a ( n = up , code = code ) type is ( integer ( I8P )) call b64_encode_I8_a ( n = up , code = code ) type is ( integer ( I4P )) call b64_encode_I4_a ( n = up , code = code ) type is ( integer ( I2P )) call b64_encode_I2_a ( n = up , code = code ) type is ( integer ( I1P )) call b64_encode_I1_a ( n = up , code = code ) type is ( character ( * )) call b64_encode_string_a ( s = up , code = code ) endselect endsubroutine b64_encode_up_a subroutine b64_decode_up ( code , up ) !< Decode an unlimited polymorphic scalar from base64. character ( * ), intent ( in ) :: code !< Encoded scalar. class ( * ), intent ( out ) :: up !< Unlimited polymorphic variable to be decoded. select type ( up ) type is ( real ( R8P )) call b64_decode_R8 ( code = code , n = up ) type is ( real ( R4P )) call b64_decode_R4 ( code = code , n = up ) type is ( integer ( I8P )) call b64_decode_I8 ( code = code , n = up ) type is ( integer ( I4P )) call b64_decode_I4 ( code = code , n = up ) type is ( integer ( I2P )) call b64_decode_I2 ( code = code , n = up ) type is ( integer ( I1P )) call b64_decode_I1 ( code = code , n = up ) type is ( character ( * )) call b64_decode_string ( code = code , s = up ) endselect endsubroutine b64_decode_up subroutine b64_decode_up_a ( code , up ) !< Decode an unlimited polymorphic array from base64. character ( * ), intent ( in ) :: code !< Encoded array. class ( * ), intent ( out ) :: up ( 1 :) !< Unlimited polymorphic variable to be decoded. select type ( up ) type is ( real ( R8P )) call b64_decode_R8_a ( code = code , n = up ) type is ( real ( R4P )) call b64_decode_R4_a ( code = code , n = up ) type is ( integer ( I8P )) call b64_decode_I8_a ( code = code , n = up ) type is ( integer ( I4P )) call b64_decode_I4_a ( code = code , n = up ) type is ( integer ( I2P )) call b64_decode_I2_a ( code = code , n = up ) type is ( integer ( I1P )) call b64_decode_I1_a ( code = code , n = up ) type is ( character ( * )) call b64_decode_string_a ( code = code , s = up ) endselect endsubroutine b64_decode_up_a pure subroutine b64_encode_R16 ( n , code ) !< Encode scalar number to base64 (R16P). real ( R16P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). allocate ( nI1P ( 1 :(( BYR16P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYR16P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYR16P ), 3_I2P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_R16 pure subroutine b64_encode_R8 ( n , code ) !< Encode scalar number to base64 (R8P). real ( R8P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). allocate ( nI1P ( 1 :(( BYR8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYR8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYR8P ), 3_I1P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_R8 pure subroutine b64_encode_R4 ( n , code ) !< Encode scalar number to base64 (R4P). real ( R4P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). allocate ( nI1P ( 1 :(( BYR4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYR4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYR4P ), 3_I1P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_R4 pure subroutine b64_encode_I8 ( n , code ) !< Encode scalar number to base64 (I8P). integer ( I8P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). allocate ( nI1P ( 1 :(( BYI8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI8P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_I8 pure subroutine b64_encode_I4 ( n , code ) !< Encode scalar number to base64 (I4P). integer ( I4P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). allocate ( nI1P ( 1 :(( BYI4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI4P ), 3_I4P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_I4 pure subroutine b64_encode_I2 ( n , code ) !< Encode scalar number to base64 (I2P). integer ( I2P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). allocate ( nI1P ( 1 :(( BYI2P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI2P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI2P ), 3_I2P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_I2 pure subroutine b64_encode_I1 ( n , code ) !< Encode scalar number to base64 (I1P). integer ( I1P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). allocate ( nI1P ( 1 :(( BYI1P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI1P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI1P ), 3_I1P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_I1 pure subroutine b64_encode_string ( s , code ) !< Encode scalar string to base64. character ( * ), intent ( in ) :: s !< String to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I4P ) :: BYCHS !< Bytes of character string. BYCHS = byte_size ( s ) allocate ( nI1P ( 1 :(( BYCHS + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYCHS + 2 ) / 3 ) * 4 ) nI1P = transfer ( s , nI1P ) padd = mod (( BYCHS ), 3_I4P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_string pure subroutine b64_encode_R16_a ( n , code ) !< Encode array numbers to base64 (R16P). real ( R16P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYR16P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYR16P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYR16P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_R16_a pure subroutine b64_encode_R8_a ( n , code ) !< Encode array numbers to base64 (R8P). real ( R8P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYR8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYR8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYR8P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_R8_a pure subroutine b64_encode_R4_a ( n , code ) !< Encode array numbers to base64 (R4P). real ( R4P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYR4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYR4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYR4P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_R4_a pure subroutine b64_encode_I8_a ( n , code ) !< Encode array numbers to base64 (I8P). integer ( I8P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI8P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_I8_a pure subroutine b64_encode_I4_a ( n , code ) !< Encode array numbers to base64 (I4P). integer ( I4P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI4P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_I4_a pure subroutine b64_encode_I2_a ( n , code ) !< Encode array numbers to base64 (I2P). integer ( I2P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI2P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI2P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI2P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_I2_a pure subroutine b64_encode_I1_a ( n , code ) !< Encode array numbers to base64 (I1P). integer ( I1P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI1P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI1P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI1P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_I1_a pure subroutine b64_encode_string_a ( s , code ) !< Encode array string to base64. character ( * ), intent ( in ) :: s ( 1 :) !< String to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I4P ) :: BYCHS !< Bytes of character string. BYCHS = byte_size ( s ( 1 )) * size ( s , dim = 1 ) allocate ( nI1P ( 1 :(( BYCHS + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYCHS + 2 ) / 3 ) * 4 ) nI1P = transfer ( s , nI1P ) padd = mod (( BYCHS ), 3_I4P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_string_a elemental subroutine b64_decode_R16 ( code , n ) !< Decode a base64 code into a scalar number (R16P). character ( * ), intent ( in ) :: code !< Encoded scalar. real ( R16P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : BYR16P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_R16 elemental subroutine b64_decode_R8 ( code , n ) !< Decode a base64 code into a scalar number (R8P). character ( * ), intent ( in ) :: code !< Encoded scalar. real ( R8P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : BYR8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_R8 elemental subroutine b64_decode_R4 ( code , n ) !< Decode a base64 code into a scalar number (R4P). character ( * ), intent ( in ) :: code !< Encoded scalar. real ( R4P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : BYR4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_R4 elemental subroutine b64_decode_I8 ( code , n ) !< Decode a base64 code into a scalar number (I8P). character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I8P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : BYI8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_I8 elemental subroutine b64_decode_I4 ( code , n ) !< Decode a base64 code into a scalar number (I4P). character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I4P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : BYI4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_I4 elemental subroutine b64_decode_I2 ( code , n ) !< Decode a base64 code into a scalar number (I2P). character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I2P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : BYI2P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_I2 elemental subroutine b64_decode_I1 ( code , n ) !< Decode a base64 code into a scalar number (I1P). character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I1P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : BYI1P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_I1 elemental subroutine b64_decode_string ( code , s ) !< Decode a base64 code into a scalar string. character ( * ), intent ( in ) :: code !< Encoded scalar. character ( * ), intent ( out ) :: s !< String to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : byte_size ( s ))) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) s = transfer ( nI1P , s ) endsubroutine b64_decode_string pure subroutine b64_decode_R16_a ( code , n ) !< Decode a base64 code into an array numbers (R16P). character ( * ), intent ( in ) :: code !< Encoded array. real ( R16P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYR16P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_R16_a pure subroutine b64_decode_R8_a ( code , n ) !< Decode a base64 code into an array numbers (R8P). character ( * ), intent ( in ) :: code !< Encoded array. real ( R8P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYR8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_R8_a pure subroutine b64_decode_R4_a ( code , n ) !< Decode a base64 code into an array numbers (R4P). character ( * ), intent ( in ) :: code !< Encoded array. real ( R4P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYR4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_R4_a pure subroutine b64_decode_I8_a ( code , n ) !< Decode a base64 code into an array numbers (I8P). character ( * ), intent ( in ) :: code !< Encoded array. integer ( I8P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_I8_a pure subroutine b64_decode_I4_a ( code , n ) !< Decode a base64 code into an array numbers (I4P). character ( * ), intent ( in ) :: code !< Encoded array. integer ( I4P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_I4_a pure subroutine b64_decode_I2_a ( code , n ) !< Decode a base64 code into an array numbers (I2P). character ( * ), intent ( in ) :: code !< Encoded array. integer ( I2P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI2P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_I2_a pure subroutine b64_decode_I1_a ( code , n ) !< Decode a base64 code into an array numbers (I1P). character ( * ), intent ( in ) :: code !< Encoded array. integer ( I1P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI1P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_I1_a pure subroutine b64_decode_string_a ( code , s ) !< Decode a base64 code into an array of strings. character ( * ), intent ( in ) :: code !< Encoded scalar. character ( * ), intent ( out ) :: s ( 1 :) !< String to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : byte_size ( s ( 1 )) * size ( s , dim = 1 ))) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) s = transfer ( nI1P , s ) endsubroutine b64_decode_string_a subroutine autotest () !< Procedure for autotesting the library functionalities. !< !< @note Into the *src* directory there is a small python script (*validation.py*) that can be used to validate the library !< correctness by a comparison with other widely used tools such as the python builtin module *struct*. character ( len = :), allocatable :: code64 !< Base64 code. logical :: ok !< Flag for checking the result of encoding/decoding. #ifdef _R16P_SUPPORTED real ( R16P ) :: scalar_R16 !< Decoded scalar. #endif real ( R8P ) :: scalar_R8 !< Decoded scalar. real ( R4P ) :: scalar_R4 !< Decoded scalar. integer ( I8P ) :: scalar_I8 !< Decoded scalar. integer ( I4P ) :: scalar_I4 !< Decoded scalar. integer ( I2P ) :: scalar_I2 !< Decoded scalar. integer ( I1P ) :: scalar_I1 !< Decoded scalar. real ( R8P ) :: array_R8 ( 1 : 2 ) !< Decoded array. real ( R4P ) :: array_R4 ( 1 : 2 ) !< Decoded array. integer ( I8P ) :: array_I8 ( 1 : 4 ) !< Decoded array. integer ( I4P ) :: array_I4 ( 1 : 2 ) !< Decoded array. integer ( I2P ) :: array_I2 ( 1 : 2 ) !< Decoded array. integer ( I1P ) :: array_I1 ( 1 : 2 ) !< Decoded array. character ( 5 ) :: array_s ( 1 : 2 ) !< Decoded array. call b64_Init print \"(A)\" , 'Encoders' print \"(A)\" , 'Scalars' #ifdef _R16P_SUPPORTED call b64_encode ( n = 13 4.231_R16P , code = code64 ) ok = code64 == 'CKwcWmTHYEA=' print \"(A)\" , '+ Code of ' // trim ( str ( n = 13 4.231_R16P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'CKwcWmTHYEA=' // '\", Is it correct?' , ok if (. not . ok ) stop #endif call b64_encode ( n = 1._R8P , code = code64 ) ok = code64 == 'AAAAAAAA8D8=' print \"(A)\" , '+ Code of ' // trim ( str ( n = 1._R8P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAAAA8D8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 0._R4P , code = code64 ) ok = code64 == 'AAAAAA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = 0._R4P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 23_I8P , code = code64 ) ok = code64 == 'FwAAAAAAAAA=' print \"(A)\" , '+ Code of ' // trim ( str ( n = 23_I8P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'FwAAAAAAAAA=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 2023_I4P , code = code64 ) ok = code64 == '5wcAAA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = 2023_I4P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // '5wcAAA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n =- 203_I2P , code = code64 ) ok = code64 == 'Nf8=' print \"(A)\" , '+ Code of ' // trim ( str ( n =- 203_I2P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'Nf8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 120_I1P , code = code64 ) ok = code64 == 'eA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = 120_I1P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'eA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( s = 'hello' , code = code64 ) ok = code64 == 'aGVsbG8=' print \"(A)\" , '+ Code of hello: \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'aGVsbG8=' // '\", Is it correct?' , ok if (. not . ok ) stop print \"(A)\" , 'Arrays' #ifdef _R16P_SUPPORTED call b64_encode ( n = [ 12 1._R16P , 2.32_R16P ], code = code64 ) ok = code64 == 'AAAAAABAXkCPwvUoXI8CQA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 12 1._R16P , 2.32_R16P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAABAXkCPwvUoXI8CQA==' // '\", Is it correct?' , ok if (. not . ok ) stop #endif call b64_encode ( n = [ 1._R8P , 2._R8P ], code = code64 ) ok = code64 == 'AAAAAAAA8D8AAAAAAAAAQA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 1._R8P , 2._R8P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAAAA8D8AAAAAAAAAQA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 0._R4P , - 3 2.12_R4P ], code = code64 ) ok = code64 == 'AAAAAOF6AMI=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 0._R4P , - 3 2.12_R4P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAOF6AMI=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ], code = code64 ) ok = code64 == 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 2023_I4P , - 24_I4P ], code = code64 ) ok = code64 == '5wcAAOj///8=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 2023_I4P , - 24_I4P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // '5wcAAOj///8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ - 203_I2P , - 10_I2P ], code = code64 ) ok = code64 == 'Nf/2/w==' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ - 203_I2P , - 10_I2P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'Nf/2/w==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 120_I1P , - 1_I1P ], code = code64 ) ok = code64 == 'eP8=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 120_I1P , - 1_I1P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'eP8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( s = [ 'hello' , 'world' ], code = code64 ) ok = code64 == 'aGVsbG93b3JsZA==' print \"(A)\" , '+ Code of [hello,world]: \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'aGVsbG93b3JsZA==' // '\", Is it correct?' , ok if (. not . ok ) stop print \"(A)\" , 'Decoders' print \"(A)\" , 'Scalars' call b64_decode ( code = 'AAAAAAAA8D8=' , n = scalar_R8 ) ok = str ( n = scalar_R8 ) == str ( n = 1._R8P ) print \"(A)\" , '+ Decode of ' // 'AAAAAAAA8D8=' // ': \"' // trim ( str ( n = scalar_R8 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 1._R8P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'AAAAAA==' , n = scalar_R4 ) ok = str ( n = scalar_R4 ) == str ( n = 0._R4P ) print \"(A)\" , '+ Decode of ' // 'AAAAAA==' // ': \"' // trim ( str ( n = scalar_R4 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 0._R4P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'FwAAAAAAAAA=' , n = scalar_I8 ) ok = str ( n = scalar_I8 ) == str ( n = 23_I8P ) print \"(A)\" , '+ Decode of ' // 'FwAAAAAAAAA=' // ': \"' // trim ( str ( n = scalar_I8 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 23_I8P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = '5wcAAA==' , n = scalar_I4 ) ok = str ( n = scalar_I4 ) == str ( n = 2023_I4P ) print \"(A)\" , '+ Decode of ' // '5wcAAA==' // ': \"' // trim ( str ( n = scalar_I4 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 2023_I4P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'Nf8=' , n = scalar_I2 ) ok = str ( n = scalar_I2 ) == str ( n =- 203_I2P ) print \"(A)\" , '+ Decode of ' // 'Nf8=' // ': \"' // trim ( str ( n = scalar_I2 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n =- 203_I2P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'eA==' , n = scalar_I1 ) ok = str ( n = scalar_I1 ) == str ( n = 120_I1P ) print \"(A)\" , '+ Decode of ' // 'eA==' // ': \"' // trim ( str ( n = scalar_I1 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 120_I1P )) // '\", Is it correct?' , ok if (. not . ok ) stop code64 = repeat ( ' ' , 5 ) call b64_decode ( code = 'aGVsbG8=' , s = code64 ) ok = 'hello' == code64 print \"(A)\" , '+ Decode of ' // 'aGVsbG8=' // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected value: \"hello\", Is it correct?' , ok if (. not . ok ) stop print \"(A)\" , 'Arrays' call b64_decode ( code = 'AAAAAAAA8D8AAAAAAAAAQA==' , n = array_R8 ) ok = str ( n = array_R8 ) == str ( n = [ 1._R8P , 2._R8P ]) print \"(A)\" , '+ Decode of ' // 'AAAAAAAA8D8AAAAAAAAAQA==' // ': \"' // trim ( str ( n = array_R8 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 1._R8P , 2._R8P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'AAAAAOF6AMI=' , n = array_R4 ) ok = str ( n = array_R4 ) == str ( n = [ 0._R4P , - 3 2.12_R4P ]) print \"(A)\" , '+ Decode of ' // 'AAAAAOF6AMI=' // ': \"' // trim ( str ( n = array_R4 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 0._R4P , - 3 2.12_R4P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop ! ok = test_decode_array(code=, input=) ; if (.not.ok) stop call b64_decode ( code = 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' , n = array_I8 ) ok = str ( n = array_I8 ) == str ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ]) print \"(A)\" , '+ Decode of ' // 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' // ': \"' // & trim ( str ( n = array_I8 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ], delimiters = [ '[' , ']' ])) // & '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = '5wcAAOj///8=' , n = array_I4 ) ok = str ( n = array_I4 ) == str ( n = [ 2023_I4P , - 24_I4P ]) print \"(A)\" , '+ Decode of ' // '5wcAAOj///8=' // ': \"' // trim ( str ( n = array_I4 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 2023_I4P , - 24_I4P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'Nf/2/w==' , n = array_I2 ) ok = str ( n = array_I2 ) == str ( n = [ - 203_I2P , - 10_I2P ]) print \"(A)\" , '+ Decode of ' // 'Nf/2/w==' // ': \"' // trim ( str ( n = array_I2 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ - 203_I2P , - 10_I2P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'eP8=' , n = array_I1 ) ok = str ( n = array_I1 ) == str ( n = [ 120_I1P , - 1_I1P ]) print \"(A)\" , '+ Decode of ' // 'eP8=' // ': \"' // trim ( str ( n = array_I1 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 120_I1P , - 1_I1P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'aGVsbG93b3JsZA==' , s = array_s ) ok = array_s ( 1 ) // array_s ( 2 ) == 'helloworld' print \"(A)\" , '+ Decode of ' // 'aGVsbG93b3JsZA==' // ': \"' // array_s ( 1 ) // array_s ( 2 ) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"helloworld\", Is it correct?' , ok if (. not . ok ) stop endsubroutine autotest endmodule befor64","tags":"","loc":"sourcefile/befor64.f90.html","title":"befor64.F90 – BeFoR64"},{"text":"KISS library for packing heterogeneous data into single (homogeneous) packed one. Files Dependent On This One sourcefile~~befor64_pack_data_m.f90~~AfferentGraph sourcefile~befor64_pack_data_m.f90 befor64_pack_data_m.F90 sourcefile~befor64.f90 befor64.F90 sourcefile~befor64_pack_data_m.f90->sourcefile~befor64.f90 sourcefile~befor64_test.f90 befor64_test.f90 sourcefile~befor64.f90->sourcefile~befor64_test.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules befor64_pack_data_m Source Code befor64_pack_data_m.F90 Source Code !< KISS library for packing heterogeneous data into single (homogeneous) packed one. module befor64_pack_data_m !< KISS library for packing heterogeneous data into single (homogeneous) packed one. use penf implicit none private public :: pack_data interface pack_data !< Pack different kinds of data into single I1P array. !< !< This is useful for encoding different (heterogeneous) kinds variables into a single (homogeneous) stream of bits. !< @note This procedure exploits the `transfer` builtin function, that from the standard (2003+) is defined as !< `TRANSFER(SOURCE, MOLD [, SIZE])`. Data object having a physical representation identical to that of `SOURCE` but with the type !< and type parameters of `MOLD`. The result is of the same type and type parameters as `MOLD`. !< If `MOLD` is an array and `SIZE` is absent, the result is an array and of rank one. Its size is as small as possible such !< that its physical representation is not shorter than that of `SOURCE`. !< !< Presently, the following combinations are available: !< !<* [ ] Arrays-Arrays: !<    * [X] real(any)-real(any); !<    * [X] real(any)-integer(any); !<    * [X] integer(any)-integer(any); !<    * [X] integer(any)-real(any); !<    * [ ] real(any)-character; !<    * [ ] character-real(any); !<    * [ ] integer(any)-character; !<    * [ ] character-integer(any); !<* [ ] Scalars-Scalars: !<    * [ ] real(any)-real(any); !<    * [ ] real(any)-integer(any); !<    * [ ] integer(any)-integer(any); !<    * [ ] integer(any)-real(any); !<    * [ ] real(any)-character; !<    * [ ] character-real(any); !<    * [ ] integer(any)-character; !<    * [ ] character-integer(any); !< !<### Examples of usage !< !<#### Packing two real arrays, one with kind R8P and one with R4P !<```fortran !<real(R8P)::                 array_r8(1:12) !<real(R4P)::                 array_r4(-1:5) !<integer(I1P), allocatable:: rpack !<... !<call pack_data(a1=array_r8,a2=array_r4,packed=rpack) !<``` !<#### Packing two arrays, one real with kind R4P and one integer with I4P !<```fortran !<real(R4P)::                 array_r4(2) !<integer(I4P)::              array_i4(0:2) !<integer(I1P), allocatable:: rpack !<... !<call pack_data(a1=array_r4,a2=array_i4,packed=rpack) !<``` module procedure pack_data_R8_R4 , pack_data_R8_I8 , pack_data_R8_I4 , pack_data_R8_I2 , pack_data_R8_I1 , & pack_data_R4_R8 , pack_data_R4_I8 , pack_data_R4_I4 , pack_data_R4_I2 , pack_data_R4_I1 , & pack_data_I8_R8 , pack_data_I8_R4 , pack_data_I8_I4 , pack_data_I8_I2 , pack_data_I8_I1 , & pack_data_I4_R8 , pack_data_I4_R4 , pack_data_I4_I8 , pack_data_I4_I2 , pack_data_I4_I1 , & pack_data_I2_R8 , pack_data_I2_R4 , pack_data_I2_I8 , pack_data_I2_I4 , pack_data_I2_I1 , & pack_data_I1_R8 , pack_data_I1_R4 , pack_data_I1_I8 , pack_data_I1_I4 , pack_data_I1_I2 endinterface contains pure subroutine pack_data_R8_R4 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. real ( R8P ), intent ( in ) :: a1 ( 1 :) !< Firs data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_R8_R4 pure subroutine pack_data_R8_I8 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_R8_I8 pure subroutine pack_data_R8_I4 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_R8_I4 pure subroutine pack_data_R8_I2 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_R8_I2 pure subroutine pack_data_R8_I1 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_R8_I1 pure subroutine pack_data_R4_R8 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. real ( R4P ), intent ( in ) :: a1 ( 1 :) !< Firs data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_R4_R8 pure subroutine pack_data_R4_I8 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_R4_I8 pure subroutine pack_data_R4_I4 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_R4_I4 pure subroutine pack_data_R4_I2 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_R4_I2 pure subroutine pack_data_R4_I1 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_R4_I1 pure subroutine pack_data_I8_R8 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I8_R8 pure subroutine pack_data_I8_R4 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I8_R4 pure subroutine pack_data_I8_I4 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I8_I4 pure subroutine pack_data_I8_I2 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I8_I2 pure subroutine pack_data_I8_I1 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I8_I1 pure subroutine pack_data_I4_R8 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I4_R8 pure subroutine pack_data_I4_R4 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I4_R4 pure subroutine pack_data_I4_I8 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I4_I8 pure subroutine pack_data_I4_I2 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I4_I2 pure subroutine pack_data_I4_I1 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I4_I1 pure subroutine pack_data_I2_R8 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I2_R8 pure subroutine pack_data_I2_R4 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I2_R4 pure subroutine pack_data_I2_I8 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I2_I8 pure subroutine pack_data_I2_I4 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I2_I4 pure subroutine pack_data_I2_I1 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I2_I1 pure subroutine pack_data_I1_R8 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I1_R8 pure subroutine pack_data_I1_R4 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I1_R4 pure subroutine pack_data_I1_I8 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I1_I8 pure subroutine pack_data_I1_I4 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I1_I4 pure subroutine pack_data_I1_I2 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I1_I2 endmodule befor64_pack_data_m","tags":"","loc":"sourcefile/befor64_pack_data_m.f90.html","title":"befor64_pack_data_m.F90 – BeFoR64"},{"text":"Testing program for BeFoR64, Base64 encoding/decoding library for FoRtran poor men This File Depends On sourcefile~~befor64_test.f90~~EfferentGraph sourcefile~befor64_test.f90 befor64_test.f90 sourcefile~befor64.f90 befor64.F90 sourcefile~befor64.f90->sourcefile~befor64_test.f90 sourcefile~befor64_pack_data_m.f90 befor64_pack_data_m.F90 sourcefile~befor64_pack_data_m.f90->sourcefile~befor64.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs befor64_test Source Code befor64_test.f90 Source Code !< Testing program for BeFoR64, Base64 encoding/decoding library for FoRtran poor men program befor64_test !< Testing program for BeFoR64, Base64 encoding/decoding library for FoRtran poor men !< !<### Usage !<```bash !< ./Test_Driver !<``` use befor64 , only : autotest ! Autotesting procedure. implicit none call autotest endprogram befor64_test","tags":"","loc":"sourcefile/befor64_test.f90.html","title":"befor64_test.f90 – BeFoR64"},{"text":"public subroutine autotest() Procedure for autotesting the library functionalities. Note Into the src directory there is a small python script ( validation.py ) that can be used to validate the library\n correctness by a comparison with other widely used tools such as the python builtin module struct . Arguments None Calls proc~~autotest~~CallsGraph proc~autotest autotest interface~b64_encode b64_encode proc~autotest->interface~b64_encode interface~b64_decode b64_decode proc~autotest->interface~b64_decode proc~b64_init b64_init proc~autotest->proc~b64_init str str proc~autotest->str proc~b64_encode_i1 b64_encode_I1 interface~b64_encode->proc~b64_encode_i1 proc~b64_encode_i4 b64_encode_I4 interface~b64_encode->proc~b64_encode_i4 proc~b64_encode_string b64_encode_string interface~b64_encode->proc~b64_encode_string proc~b64_encode_i2_a b64_encode_I2_a interface~b64_encode->proc~b64_encode_i2_a proc~b64_encode_i8 b64_encode_I8 interface~b64_encode->proc~b64_encode_i8 proc~b64_encode_r8_a b64_encode_R8_a interface~b64_encode->proc~b64_encode_r8_a proc~b64_encode_i4_a b64_encode_I4_a interface~b64_encode->proc~b64_encode_i4_a proc~b64_encode_r8 b64_encode_R8 interface~b64_encode->proc~b64_encode_r8 proc~b64_encode_i1_a b64_encode_I1_a interface~b64_encode->proc~b64_encode_i1_a proc~b64_encode_r4_a b64_encode_R4_a interface~b64_encode->proc~b64_encode_r4_a proc~b64_encode_r4 b64_encode_R4 interface~b64_encode->proc~b64_encode_r4 proc~b64_encode_string_a b64_encode_string_a interface~b64_encode->proc~b64_encode_string_a proc~b64_encode_i8_a b64_encode_I8_a interface~b64_encode->proc~b64_encode_i8_a proc~b64_encode_i2 b64_encode_I2 interface~b64_encode->proc~b64_encode_i2 proc~b64_decode_r8 b64_decode_R8 interface~b64_decode->proc~b64_decode_r8 proc~b64_decode_i1_a b64_decode_I1_a interface~b64_decode->proc~b64_decode_i1_a proc~b64_decode_i2 b64_decode_I2 interface~b64_decode->proc~b64_decode_i2 proc~b64_decode_r4 b64_decode_R4 interface~b64_decode->proc~b64_decode_r4 proc~b64_decode_r4_a b64_decode_R4_a interface~b64_decode->proc~b64_decode_r4_a proc~b64_decode_string b64_decode_string interface~b64_decode->proc~b64_decode_string proc~b64_decode_i8 b64_decode_I8 interface~b64_decode->proc~b64_decode_i8 proc~b64_decode_i1 b64_decode_I1 interface~b64_decode->proc~b64_decode_i1 proc~b64_decode_i8_a b64_decode_I8_a interface~b64_decode->proc~b64_decode_i8_a proc~b64_decode_string_a b64_decode_string_a interface~b64_decode->proc~b64_decode_string_a proc~b64_decode_i4 b64_decode_I4 interface~b64_decode->proc~b64_decode_i4 proc~b64_decode_i2_a b64_decode_I2_a interface~b64_decode->proc~b64_decode_i2_a proc~b64_decode_r8_a b64_decode_R8_a interface~b64_decode->proc~b64_decode_r8_a proc~b64_decode_i4_a b64_decode_I4_a interface~b64_decode->proc~b64_decode_i4_a proc~encode_bits encode_bits proc~b64_encode_i1->proc~encode_bits proc~b64_encode_i4->proc~encode_bits proc~b64_encode_string->proc~encode_bits byte_size byte_size proc~b64_encode_string->byte_size proc~b64_encode_i2_a->proc~encode_bits proc~b64_encode_i8->proc~encode_bits proc~b64_encode_r8_a->proc~encode_bits proc~b64_encode_i4_a->proc~encode_bits proc~b64_encode_r8->proc~encode_bits proc~b64_encode_i1_a->proc~encode_bits proc~b64_encode_r4_a->proc~encode_bits proc~b64_encode_r4->proc~encode_bits proc~b64_encode_string_a->proc~encode_bits proc~b64_encode_string_a->byte_size proc~b64_encode_i8_a->proc~encode_bits proc~b64_encode_i2->proc~encode_bits proc~decode_bits decode_bits proc~b64_decode_r8->proc~decode_bits proc~b64_decode_i1_a->proc~decode_bits proc~b64_decode_i2->proc~decode_bits proc~b64_decode_r4->proc~decode_bits proc~b64_decode_r4_a->proc~decode_bits proc~b64_decode_string->byte_size proc~b64_decode_string->proc~decode_bits proc~b64_decode_i8->proc~decode_bits proc~b64_decode_i1->proc~decode_bits proc~b64_decode_i8_a->proc~decode_bits proc~b64_decode_string_a->byte_size proc~b64_decode_string_a->proc~decode_bits proc~b64_decode_i4->proc~decode_bits proc~b64_decode_i2_a->proc~decode_bits proc~b64_decode_r8_a->proc~decode_bits proc~b64_decode_i4_a->proc~decode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~autotest~~CalledByGraph proc~autotest autotest program~befor64_test befor64_test program~befor64_test->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code autotest Source Code subroutine autotest () !< Procedure for autotesting the library functionalities. !< !< @note Into the *src* directory there is a small python script (*validation.py*) that can be used to validate the library !< correctness by a comparison with other widely used tools such as the python builtin module *struct*. character ( len = :), allocatable :: code64 !< Base64 code. logical :: ok !< Flag for checking the result of encoding/decoding. #ifdef _R16P_SUPPORTED real ( R16P ) :: scalar_R16 !< Decoded scalar. #endif real ( R8P ) :: scalar_R8 !< Decoded scalar. real ( R4P ) :: scalar_R4 !< Decoded scalar. integer ( I8P ) :: scalar_I8 !< Decoded scalar. integer ( I4P ) :: scalar_I4 !< Decoded scalar. integer ( I2P ) :: scalar_I2 !< Decoded scalar. integer ( I1P ) :: scalar_I1 !< Decoded scalar. real ( R8P ) :: array_R8 ( 1 : 2 ) !< Decoded array. real ( R4P ) :: array_R4 ( 1 : 2 ) !< Decoded array. integer ( I8P ) :: array_I8 ( 1 : 4 ) !< Decoded array. integer ( I4P ) :: array_I4 ( 1 : 2 ) !< Decoded array. integer ( I2P ) :: array_I2 ( 1 : 2 ) !< Decoded array. integer ( I1P ) :: array_I1 ( 1 : 2 ) !< Decoded array. character ( 5 ) :: array_s ( 1 : 2 ) !< Decoded array. call b64_Init print \"(A)\" , 'Encoders' print \"(A)\" , 'Scalars' #ifdef _R16P_SUPPORTED call b64_encode ( n = 13 4.231_R16P , code = code64 ) ok = code64 == 'CKwcWmTHYEA=' print \"(A)\" , '+ Code of ' // trim ( str ( n = 13 4.231_R16P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'CKwcWmTHYEA=' // '\", Is it correct?' , ok if (. not . ok ) stop #endif call b64_encode ( n = 1._R8P , code = code64 ) ok = code64 == 'AAAAAAAA8D8=' print \"(A)\" , '+ Code of ' // trim ( str ( n = 1._R8P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAAAA8D8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 0._R4P , code = code64 ) ok = code64 == 'AAAAAA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = 0._R4P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 23_I8P , code = code64 ) ok = code64 == 'FwAAAAAAAAA=' print \"(A)\" , '+ Code of ' // trim ( str ( n = 23_I8P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'FwAAAAAAAAA=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 2023_I4P , code = code64 ) ok = code64 == '5wcAAA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = 2023_I4P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // '5wcAAA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n =- 203_I2P , code = code64 ) ok = code64 == 'Nf8=' print \"(A)\" , '+ Code of ' // trim ( str ( n =- 203_I2P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'Nf8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = 120_I1P , code = code64 ) ok = code64 == 'eA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = 120_I1P )) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'eA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( s = 'hello' , code = code64 ) ok = code64 == 'aGVsbG8=' print \"(A)\" , '+ Code of hello: \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'aGVsbG8=' // '\", Is it correct?' , ok if (. not . ok ) stop print \"(A)\" , 'Arrays' #ifdef _R16P_SUPPORTED call b64_encode ( n = [ 12 1._R16P , 2.32_R16P ], code = code64 ) ok = code64 == 'AAAAAABAXkCPwvUoXI8CQA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 12 1._R16P , 2.32_R16P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAABAXkCPwvUoXI8CQA==' // '\", Is it correct?' , ok if (. not . ok ) stop #endif call b64_encode ( n = [ 1._R8P , 2._R8P ], code = code64 ) ok = code64 == 'AAAAAAAA8D8AAAAAAAAAQA==' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 1._R8P , 2._R8P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAAAA8D8AAAAAAAAAQA==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 0._R4P , - 3 2.12_R4P ], code = code64 ) ok = code64 == 'AAAAAOF6AMI=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 0._R4P , - 3 2.12_R4P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'AAAAAOF6AMI=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ], code = code64 ) ok = code64 == 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 2023_I4P , - 24_I4P ], code = code64 ) ok = code64 == '5wcAAOj///8=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 2023_I4P , - 24_I4P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // '5wcAAOj///8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ - 203_I2P , - 10_I2P ], code = code64 ) ok = code64 == 'Nf/2/w==' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ - 203_I2P , - 10_I2P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'Nf/2/w==' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( n = [ 120_I1P , - 1_I1P ], code = code64 ) ok = code64 == 'eP8=' print \"(A)\" , '+ Code of ' // trim ( str ( n = [ 120_I1P , - 1_I1P ], delimiters = [ '[' , ']' ])) // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'eP8=' // '\", Is it correct?' , ok if (. not . ok ) stop call b64_encode ( s = [ 'hello' , 'world' ], code = code64 ) ok = code64 == 'aGVsbG93b3JsZA==' print \"(A)\" , '+ Code of [hello,world]: \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected code: \"' // 'aGVsbG93b3JsZA==' // '\", Is it correct?' , ok if (. not . ok ) stop print \"(A)\" , 'Decoders' print \"(A)\" , 'Scalars' call b64_decode ( code = 'AAAAAAAA8D8=' , n = scalar_R8 ) ok = str ( n = scalar_R8 ) == str ( n = 1._R8P ) print \"(A)\" , '+ Decode of ' // 'AAAAAAAA8D8=' // ': \"' // trim ( str ( n = scalar_R8 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 1._R8P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'AAAAAA==' , n = scalar_R4 ) ok = str ( n = scalar_R4 ) == str ( n = 0._R4P ) print \"(A)\" , '+ Decode of ' // 'AAAAAA==' // ': \"' // trim ( str ( n = scalar_R4 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 0._R4P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'FwAAAAAAAAA=' , n = scalar_I8 ) ok = str ( n = scalar_I8 ) == str ( n = 23_I8P ) print \"(A)\" , '+ Decode of ' // 'FwAAAAAAAAA=' // ': \"' // trim ( str ( n = scalar_I8 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 23_I8P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = '5wcAAA==' , n = scalar_I4 ) ok = str ( n = scalar_I4 ) == str ( n = 2023_I4P ) print \"(A)\" , '+ Decode of ' // '5wcAAA==' // ': \"' // trim ( str ( n = scalar_I4 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 2023_I4P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'Nf8=' , n = scalar_I2 ) ok = str ( n = scalar_I2 ) == str ( n =- 203_I2P ) print \"(A)\" , '+ Decode of ' // 'Nf8=' // ': \"' // trim ( str ( n = scalar_I2 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n =- 203_I2P )) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'eA==' , n = scalar_I1 ) ok = str ( n = scalar_I1 ) == str ( n = 120_I1P ) print \"(A)\" , '+ Decode of ' // 'eA==' // ': \"' // trim ( str ( n = scalar_I1 )) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = 120_I1P )) // '\", Is it correct?' , ok if (. not . ok ) stop code64 = repeat ( ' ' , 5 ) call b64_decode ( code = 'aGVsbG8=' , s = code64 ) ok = 'hello' == code64 print \"(A)\" , '+ Decode of ' // 'aGVsbG8=' // ': \"' // code64 // '\"' print \"(A,1X,L1)\" , '  Expected value: \"hello\", Is it correct?' , ok if (. not . ok ) stop print \"(A)\" , 'Arrays' call b64_decode ( code = 'AAAAAAAA8D8AAAAAAAAAQA==' , n = array_R8 ) ok = str ( n = array_R8 ) == str ( n = [ 1._R8P , 2._R8P ]) print \"(A)\" , '+ Decode of ' // 'AAAAAAAA8D8AAAAAAAAAQA==' // ': \"' // trim ( str ( n = array_R8 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 1._R8P , 2._R8P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'AAAAAOF6AMI=' , n = array_R4 ) ok = str ( n = array_R4 ) == str ( n = [ 0._R4P , - 3 2.12_R4P ]) print \"(A)\" , '+ Decode of ' // 'AAAAAOF6AMI=' // ': \"' // trim ( str ( n = array_R4 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 0._R4P , - 3 2.12_R4P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop ! ok = test_decode_array(code=, input=) ; if (.not.ok) stop call b64_decode ( code = 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' , n = array_I8 ) ok = str ( n = array_I8 ) == str ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ]) print \"(A)\" , '+ Decode of ' // 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' // ': \"' // & trim ( str ( n = array_I8 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 23_I8P , 324_I8P , 25456656_I8P , 2_I8P ], delimiters = [ '[' , ']' ])) // & '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = '5wcAAOj///8=' , n = array_I4 ) ok = str ( n = array_I4 ) == str ( n = [ 2023_I4P , - 24_I4P ]) print \"(A)\" , '+ Decode of ' // '5wcAAOj///8=' // ': \"' // trim ( str ( n = array_I4 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 2023_I4P , - 24_I4P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'Nf/2/w==' , n = array_I2 ) ok = str ( n = array_I2 ) == str ( n = [ - 203_I2P , - 10_I2P ]) print \"(A)\" , '+ Decode of ' // 'Nf/2/w==' // ': \"' // trim ( str ( n = array_I2 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ - 203_I2P , - 10_I2P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'eP8=' , n = array_I1 ) ok = str ( n = array_I1 ) == str ( n = [ 120_I1P , - 1_I1P ]) print \"(A)\" , '+ Decode of ' // 'eP8=' // ': \"' // trim ( str ( n = array_I1 , delimiters = [ '[' , ']' ])) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"' // trim ( str ( n = [ 120_I1P , - 1_I1P ], delimiters = [ '[' , ']' ])) // '\", Is it correct?' , ok if (. not . ok ) stop call b64_decode ( code = 'aGVsbG93b3JsZA==' , s = array_s ) ok = array_s ( 1 ) // array_s ( 2 ) == 'helloworld' print \"(A)\" , '+ Decode of ' // 'aGVsbG93b3JsZA==' // ': \"' // array_s ( 1 ) // array_s ( 2 ) // '\"' print \"(A,1X,L1)\" , '  Expected value: \"helloworld\", Is it correct?' , ok if (. not . ok ) stop endsubroutine autotest","tags":"","loc":"proc/autotest.html","title":"autotest – BeFoR64"},{"text":"private elemental subroutine b64_decode_I1(code, n) Decode a base64 code into a scalar number (I1P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I1P), intent(out) :: n Number to be decoded. Calls proc~~b64_decode_i1~~CallsGraph proc~b64_decode_i1 b64_decode_I1 proc~decode_bits decode_bits proc~b64_decode_i1->proc~decode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i1~~CalledByGraph proc~b64_decode_i1 b64_decode_I1 proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_i1 interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_i1 proc~autotest autotest proc~autotest->interface~b64_decode program~befor64_test befor64_test program~befor64_test->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code b64_decode_I1 Source Code elemental subroutine b64_decode_I1 ( code , n ) !< Decode a base64 code into a scalar number (I1P). character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I1P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : BYI1P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_I1","tags":"","loc":"proc/b64_decode_i1.html","title":"b64_decode_I1 – BeFoR64"},{"text":"private pure subroutine b64_decode_I1_a(code, n) Decode a base64 code into an array numbers (I1P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I1P), intent(out) :: n (1:) Array of numbers to be decoded. Calls proc~~b64_decode_i1_a~~CallsGraph proc~b64_decode_i1_a b64_decode_I1_a proc~decode_bits decode_bits proc~b64_decode_i1_a->proc~decode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i1_a~~CalledByGraph proc~b64_decode_i1_a b64_decode_I1_a proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_i1_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_i1_a proc~autotest autotest proc~autotest->interface~b64_decode program~befor64_test befor64_test program~befor64_test->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code b64_decode_I1_a Source Code pure subroutine b64_decode_I1_a ( code , n ) !< Decode a base64 code into an array numbers (I1P). character ( * ), intent ( in ) :: code !< Encoded array. integer ( I1P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI1P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_I1_a","tags":"","loc":"proc/b64_decode_i1_a.html","title":"b64_decode_I1_a – BeFoR64"},{"text":"private elemental subroutine b64_decode_I2(code, n) Decode a base64 code into a scalar number (I2P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I2P), intent(out) :: n Number to be decoded. Calls proc~~b64_decode_i2~~CallsGraph proc~b64_decode_i2 b64_decode_I2 proc~decode_bits decode_bits proc~b64_decode_i2->proc~decode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i2~~CalledByGraph proc~b64_decode_i2 b64_decode_I2 proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_i2 interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_i2 proc~autotest autotest proc~autotest->interface~b64_decode program~befor64_test befor64_test program~befor64_test->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code b64_decode_I2 Source Code elemental subroutine b64_decode_I2 ( code , n ) !< Decode a base64 code into a scalar number (I2P). character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I2P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : BYI2P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_I2","tags":"","loc":"proc/b64_decode_i2.html","title":"b64_decode_I2 – BeFoR64"},{"text":"private pure subroutine b64_decode_I2_a(code, n) Decode a base64 code into an array numbers (I2P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I2P), intent(out) :: n (1:) Array of numbers to be decoded. Calls proc~~b64_decode_i2_a~~CallsGraph proc~b64_decode_i2_a b64_decode_I2_a proc~decode_bits decode_bits proc~b64_decode_i2_a->proc~decode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i2_a~~CalledByGraph proc~b64_decode_i2_a b64_decode_I2_a proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_i2_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_i2_a proc~autotest autotest proc~autotest->interface~b64_decode program~befor64_test befor64_test program~befor64_test->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code b64_decode_I2_a Source Code pure subroutine b64_decode_I2_a ( code , n ) !< Decode a base64 code into an array numbers (I2P). character ( * ), intent ( in ) :: code !< Encoded array. integer ( I2P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI2P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_I2_a","tags":"","loc":"proc/b64_decode_i2_a.html","title":"b64_decode_I2_a – BeFoR64"},{"text":"private elemental subroutine b64_decode_I4(code, n) Decode a base64 code into a scalar number (I4P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I4P), intent(out) :: n Number to be decoded. Calls proc~~b64_decode_i4~~CallsGraph proc~b64_decode_i4 b64_decode_I4 proc~decode_bits decode_bits proc~b64_decode_i4->proc~decode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i4~~CalledByGraph proc~b64_decode_i4 b64_decode_I4 proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_i4 interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_i4 proc~autotest autotest proc~autotest->interface~b64_decode program~befor64_test befor64_test program~befor64_test->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code b64_decode_I4 Source Code elemental subroutine b64_decode_I4 ( code , n ) !< Decode a base64 code into a scalar number (I4P). character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I4P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : BYI4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_I4","tags":"","loc":"proc/b64_decode_i4.html","title":"b64_decode_I4 – BeFoR64"},{"text":"private pure subroutine b64_decode_I4_a(code, n) Decode a base64 code into an array numbers (I4P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I4P), intent(out) :: n (1:) Array of numbers to be decoded. Calls proc~~b64_decode_i4_a~~CallsGraph proc~b64_decode_i4_a b64_decode_I4_a proc~decode_bits decode_bits proc~b64_decode_i4_a->proc~decode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i4_a~~CalledByGraph proc~b64_decode_i4_a b64_decode_I4_a proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_i4_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_i4_a proc~autotest autotest proc~autotest->interface~b64_decode program~befor64_test befor64_test program~befor64_test->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code b64_decode_I4_a Source Code pure subroutine b64_decode_I4_a ( code , n ) !< Decode a base64 code into an array numbers (I4P). character ( * ), intent ( in ) :: code !< Encoded array. integer ( I4P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_I4_a","tags":"","loc":"proc/b64_decode_i4_a.html","title":"b64_decode_I4_a – BeFoR64"},{"text":"private elemental subroutine b64_decode_I8(code, n) Decode a base64 code into a scalar number (I8P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I8P), intent(out) :: n Number to be decoded. Calls proc~~b64_decode_i8~~CallsGraph proc~b64_decode_i8 b64_decode_I8 proc~decode_bits decode_bits proc~b64_decode_i8->proc~decode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i8~~CalledByGraph proc~b64_decode_i8 b64_decode_I8 proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_i8 interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_i8 proc~autotest autotest proc~autotest->interface~b64_decode program~befor64_test befor64_test program~befor64_test->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code b64_decode_I8 Source Code elemental subroutine b64_decode_I8 ( code , n ) !< Decode a base64 code into a scalar number (I8P). character ( * ), intent ( in ) :: code !< Encoded scalar. integer ( I8P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : BYI8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_I8","tags":"","loc":"proc/b64_decode_i8.html","title":"b64_decode_I8 – BeFoR64"},{"text":"private pure subroutine b64_decode_I8_a(code, n) Decode a base64 code into an array numbers (I8P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I8P), intent(out) :: n (1:) Array of numbers to be decoded. Calls proc~~b64_decode_i8_a~~CallsGraph proc~b64_decode_i8_a b64_decode_I8_a proc~decode_bits decode_bits proc~b64_decode_i8_a->proc~decode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_i8_a~~CalledByGraph proc~b64_decode_i8_a b64_decode_I8_a proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_i8_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_i8_a proc~autotest autotest proc~autotest->interface~b64_decode program~befor64_test befor64_test program~befor64_test->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code b64_decode_I8_a Source Code pure subroutine b64_decode_I8_a ( code , n ) !< Decode a base64 code into an array numbers (I8P). character ( * ), intent ( in ) :: code !< Encoded array. integer ( I8P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYI8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_I8_a","tags":"","loc":"proc/b64_decode_i8_a.html","title":"b64_decode_I8_a – BeFoR64"},{"text":"private elemental subroutine b64_decode_R16(code, n) Decode a base64 code into a scalar number (R16P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R16P), intent(out) :: n Number to be decoded. Calls proc~~b64_decode_r16~~CallsGraph proc~b64_decode_r16 b64_decode_R16 proc~decode_bits decode_bits proc~b64_decode_r16->proc~decode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code b64_decode_R16 Source Code elemental subroutine b64_decode_R16 ( code , n ) !< Decode a base64 code into a scalar number (R16P). character ( * ), intent ( in ) :: code !< Encoded scalar. real ( R16P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : BYR16P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_R16","tags":"","loc":"proc/b64_decode_r16.html","title":"b64_decode_R16 – BeFoR64"},{"text":"private pure subroutine b64_decode_R16_a(code, n) Decode a base64 code into an array numbers (R16P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R16P), intent(out) :: n (1:) Array of numbers to be decoded. Calls proc~~b64_decode_r16_a~~CallsGraph proc~b64_decode_r16_a b64_decode_R16_a proc~decode_bits decode_bits proc~b64_decode_r16_a->proc~decode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code b64_decode_R16_a Source Code pure subroutine b64_decode_R16_a ( code , n ) !< Decode a base64 code into an array numbers (R16P). character ( * ), intent ( in ) :: code !< Encoded array. real ( R16P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYR16P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_R16_a","tags":"","loc":"proc/b64_decode_r16_a.html","title":"b64_decode_R16_a – BeFoR64"},{"text":"private elemental subroutine b64_decode_R4(code, n) Decode a base64 code into a scalar number (R4P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R4P), intent(out) :: n Number to be decoded. Calls proc~~b64_decode_r4~~CallsGraph proc~b64_decode_r4 b64_decode_R4 proc~decode_bits decode_bits proc~b64_decode_r4->proc~decode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_r4~~CalledByGraph proc~b64_decode_r4 b64_decode_R4 proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_r4 interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_r4 proc~autotest autotest proc~autotest->interface~b64_decode program~befor64_test befor64_test program~befor64_test->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code b64_decode_R4 Source Code elemental subroutine b64_decode_R4 ( code , n ) !< Decode a base64 code into a scalar number (R4P). character ( * ), intent ( in ) :: code !< Encoded scalar. real ( R4P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : BYR4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_R4","tags":"","loc":"proc/b64_decode_r4.html","title":"b64_decode_R4 – BeFoR64"},{"text":"private pure subroutine b64_decode_R4_a(code, n) Decode a base64 code into an array numbers (R4P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R4P), intent(out) :: n (1:) Array of numbers to be decoded. Calls proc~~b64_decode_r4_a~~CallsGraph proc~b64_decode_r4_a b64_decode_R4_a proc~decode_bits decode_bits proc~b64_decode_r4_a->proc~decode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_r4_a~~CalledByGraph proc~b64_decode_r4_a b64_decode_R4_a proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_r4_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_r4_a proc~autotest autotest proc~autotest->interface~b64_decode program~befor64_test befor64_test program~befor64_test->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code b64_decode_R4_a Source Code pure subroutine b64_decode_R4_a ( code , n ) !< Decode a base64 code into an array numbers (R4P). character ( * ), intent ( in ) :: code !< Encoded array. real ( R4P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYR4P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_R4_a","tags":"","loc":"proc/b64_decode_r4_a.html","title":"b64_decode_R4_a – BeFoR64"},{"text":"private elemental subroutine b64_decode_R8(code, n) Decode a base64 code into a scalar number (R8P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R8P), intent(out) :: n Number to be decoded. Calls proc~~b64_decode_r8~~CallsGraph proc~b64_decode_r8 b64_decode_R8 proc~decode_bits decode_bits proc~b64_decode_r8->proc~decode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_r8~~CalledByGraph proc~b64_decode_r8 b64_decode_R8 proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_r8 interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_r8 proc~autotest autotest proc~autotest->interface~b64_decode program~befor64_test befor64_test program~befor64_test->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code b64_decode_R8 Source Code elemental subroutine b64_decode_R8 ( code , n ) !< Decode a base64 code into a scalar number (R8P). character ( * ), intent ( in ) :: code !< Encoded scalar. real ( R8P ), intent ( out ) :: n !< Number to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : BYR8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_R8","tags":"","loc":"proc/b64_decode_r8.html","title":"b64_decode_R8 – BeFoR64"},{"text":"private pure subroutine b64_decode_R8_a(code, n) Decode a base64 code into an array numbers (R8P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R8P), intent(out) :: n (1:) Array of numbers to be decoded. Calls proc~~b64_decode_r8_a~~CallsGraph proc~b64_decode_r8_a b64_decode_R8_a proc~decode_bits decode_bits proc~b64_decode_r8_a->proc~decode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_r8_a~~CalledByGraph proc~b64_decode_r8_a b64_decode_R8_a proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_r8_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_r8_a proc~autotest autotest proc~autotest->interface~b64_decode program~befor64_test befor64_test program~befor64_test->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code b64_decode_R8_a Source Code pure subroutine b64_decode_R8_a ( code , n ) !< Decode a base64 code into an array numbers (R8P). character ( * ), intent ( in ) :: code !< Encoded array. real ( R8P ), intent ( out ) :: n ( 1 :) !< Array of numbers to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : size ( n , dim = 1 ) * BYR8P )) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) n = transfer ( nI1P , n ) endsubroutine b64_decode_R8_a","tags":"","loc":"proc/b64_decode_r8_a.html","title":"b64_decode_R8_a – BeFoR64"},{"text":"private elemental subroutine b64_decode_string(code, s) Decode a base64 code into a scalar string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s String to be decoded. Calls proc~~b64_decode_string~~CallsGraph proc~b64_decode_string b64_decode_string byte_size byte_size proc~b64_decode_string->byte_size proc~decode_bits decode_bits proc~b64_decode_string->proc~decode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_string~~CalledByGraph proc~b64_decode_string b64_decode_string proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_string interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_string proc~autotest autotest proc~autotest->interface~b64_decode program~befor64_test befor64_test program~befor64_test->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code b64_decode_string Source Code elemental subroutine b64_decode_string ( code , s ) !< Decode a base64 code into a scalar string. character ( * ), intent ( in ) :: code !< Encoded scalar. character ( * ), intent ( out ) :: s !< String to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : byte_size ( s ))) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) s = transfer ( nI1P , s ) endsubroutine b64_decode_string","tags":"","loc":"proc/b64_decode_string.html","title":"b64_decode_string – BeFoR64"},{"text":"private pure subroutine b64_decode_string_a(code, s) Decode a base64 code into an array of strings. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s (1:) String to be decoded. Calls proc~~b64_decode_string_a~~CallsGraph proc~b64_decode_string_a b64_decode_string_a byte_size byte_size proc~b64_decode_string_a->byte_size proc~decode_bits decode_bits proc~b64_decode_string_a->proc~decode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_string_a~~CalledByGraph proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_string_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_string_a proc~autotest autotest proc~autotest->interface~b64_decode program~befor64_test befor64_test program~befor64_test->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code b64_decode_string_a Source Code pure subroutine b64_decode_string_a ( code , s ) !< Decode a base64 code into an array of strings. character ( * ), intent ( in ) :: code !< Encoded scalar. character ( * ), intent ( out ) :: s ( 1 :) !< String to be decoded. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. allocate ( nI1P ( 1 : byte_size ( s ( 1 )) * size ( s , dim = 1 ))) ; nI1P = 0_I1P call decode_bits ( code = code , bits = nI1P ) s = transfer ( nI1P , s ) endsubroutine b64_decode_string_a","tags":"","loc":"proc/b64_decode_string_a.html","title":"b64_decode_string_a – BeFoR64"},{"text":"public subroutine b64_decode_up(code, up) Decode an unlimited polymorphic scalar from base64. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. class(*), intent(out) :: up Unlimited polymorphic variable to be decoded. Calls proc~~b64_decode_up~~CallsGraph proc~b64_decode_up b64_decode_up proc~b64_decode_r8 b64_decode_R8 proc~b64_decode_up->proc~b64_decode_r8 proc~b64_decode_i2 b64_decode_I2 proc~b64_decode_up->proc~b64_decode_i2 proc~b64_decode_i8 b64_decode_I8 proc~b64_decode_up->proc~b64_decode_i8 proc~b64_decode_r4 b64_decode_R4 proc~b64_decode_up->proc~b64_decode_r4 proc~b64_decode_i4 b64_decode_I4 proc~b64_decode_up->proc~b64_decode_i4 proc~b64_decode_i1 b64_decode_I1 proc~b64_decode_up->proc~b64_decode_i1 proc~b64_decode_string b64_decode_string proc~b64_decode_up->proc~b64_decode_string proc~decode_bits decode_bits proc~b64_decode_r8->proc~decode_bits proc~b64_decode_i2->proc~decode_bits proc~b64_decode_i8->proc~decode_bits proc~b64_decode_r4->proc~decode_bits proc~b64_decode_i4->proc~decode_bits proc~b64_decode_i1->proc~decode_bits proc~b64_decode_string->proc~decode_bits byte_size byte_size proc~b64_decode_string->byte_size Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code b64_decode_up Source Code subroutine b64_decode_up ( code , up ) !< Decode an unlimited polymorphic scalar from base64. character ( * ), intent ( in ) :: code !< Encoded scalar. class ( * ), intent ( out ) :: up !< Unlimited polymorphic variable to be decoded. select type ( up ) type is ( real ( R8P )) call b64_decode_R8 ( code = code , n = up ) type is ( real ( R4P )) call b64_decode_R4 ( code = code , n = up ) type is ( integer ( I8P )) call b64_decode_I8 ( code = code , n = up ) type is ( integer ( I4P )) call b64_decode_I4 ( code = code , n = up ) type is ( integer ( I2P )) call b64_decode_I2 ( code = code , n = up ) type is ( integer ( I1P )) call b64_decode_I1 ( code = code , n = up ) type is ( character ( * )) call b64_decode_string ( code = code , s = up ) endselect endsubroutine b64_decode_up","tags":"","loc":"proc/b64_decode_up.html","title":"b64_decode_up – BeFoR64"},{"text":"private subroutine b64_decode_up_a(code, up) Decode an unlimited polymorphic array from base64. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. class(*), intent(out) :: up (1:) Unlimited polymorphic variable to be decoded. Calls proc~~b64_decode_up_a~~CallsGraph proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_r4_a b64_decode_R4_a proc~b64_decode_up_a->proc~b64_decode_r4_a proc~b64_decode_i1_a b64_decode_I1_a proc~b64_decode_up_a->proc~b64_decode_i1_a proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_up_a->proc~b64_decode_string_a proc~b64_decode_i8_a b64_decode_I8_a proc~b64_decode_up_a->proc~b64_decode_i8_a proc~b64_decode_i4_a b64_decode_I4_a proc~b64_decode_up_a->proc~b64_decode_i4_a proc~b64_decode_i2_a b64_decode_I2_a proc~b64_decode_up_a->proc~b64_decode_i2_a proc~b64_decode_r8_a b64_decode_R8_a proc~b64_decode_up_a->proc~b64_decode_r8_a proc~decode_bits decode_bits proc~b64_decode_r4_a->proc~decode_bits proc~b64_decode_i1_a->proc~decode_bits proc~b64_decode_string_a->proc~decode_bits byte_size byte_size proc~b64_decode_string_a->byte_size proc~b64_decode_i8_a->proc~decode_bits proc~b64_decode_i4_a->proc~decode_bits proc~b64_decode_i2_a->proc~decode_bits proc~b64_decode_r8_a->proc~decode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~b64_decode_up_a~~CalledByGraph proc~b64_decode_up_a b64_decode_up_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code b64_decode_up_a Source Code subroutine b64_decode_up_a ( code , up ) !< Decode an unlimited polymorphic array from base64. character ( * ), intent ( in ) :: code !< Encoded array. class ( * ), intent ( out ) :: up ( 1 :) !< Unlimited polymorphic variable to be decoded. select type ( up ) type is ( real ( R8P )) call b64_decode_R8_a ( code = code , n = up ) type is ( real ( R4P )) call b64_decode_R4_a ( code = code , n = up ) type is ( integer ( I8P )) call b64_decode_I8_a ( code = code , n = up ) type is ( integer ( I4P )) call b64_decode_I4_a ( code = code , n = up ) type is ( integer ( I2P )) call b64_decode_I2_a ( code = code , n = up ) type is ( integer ( I1P )) call b64_decode_I1_a ( code = code , n = up ) type is ( character ( * )) call b64_decode_string_a ( code = code , s = up ) endselect endsubroutine b64_decode_up_a","tags":"","loc":"proc/b64_decode_up_a.html","title":"b64_decode_up_a – BeFoR64"},{"text":"private pure subroutine b64_encode_I1(n, code) Encode scalar number to base64 (I1P). Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Calls proc~~b64_encode_i1~~CallsGraph proc~b64_encode_i1 b64_encode_I1 proc~encode_bits encode_bits proc~b64_encode_i1->proc~encode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i1~~CalledByGraph proc~b64_encode_i1 b64_encode_I1 proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_i1 interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_i1 proc~autotest autotest proc~autotest->interface~b64_encode program~befor64_test befor64_test program~befor64_test->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code b64_encode_I1 Source Code pure subroutine b64_encode_I1 ( n , code ) !< Encode scalar number to base64 (I1P). integer ( I1P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). allocate ( nI1P ( 1 :(( BYI1P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI1P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI1P ), 3_I1P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_I1","tags":"","loc":"proc/b64_encode_i1.html","title":"b64_encode_I1 – BeFoR64"},{"text":"private pure subroutine b64_encode_I1_a(n, code) Encode array numbers to base64 (I1P). Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Calls proc~~b64_encode_i1_a~~CallsGraph proc~b64_encode_i1_a b64_encode_I1_a proc~encode_bits encode_bits proc~b64_encode_i1_a->proc~encode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i1_a~~CalledByGraph proc~b64_encode_i1_a b64_encode_I1_a proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_i1_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_i1_a proc~autotest autotest proc~autotest->interface~b64_encode program~befor64_test befor64_test program~befor64_test->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code b64_encode_I1_a Source Code pure subroutine b64_encode_I1_a ( n , code ) !< Encode array numbers to base64 (I1P). integer ( I1P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI1P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI1P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI1P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_I1_a","tags":"","loc":"proc/b64_encode_i1_a.html","title":"b64_encode_I1_a – BeFoR64"},{"text":"private pure subroutine b64_encode_I2(n, code) Encode scalar number to base64 (I2P). Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Calls proc~~b64_encode_i2~~CallsGraph proc~b64_encode_i2 b64_encode_I2 proc~encode_bits encode_bits proc~b64_encode_i2->proc~encode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i2~~CalledByGraph proc~b64_encode_i2 b64_encode_I2 proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_i2 interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_i2 proc~autotest autotest proc~autotest->interface~b64_encode program~befor64_test befor64_test program~befor64_test->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code b64_encode_I2 Source Code pure subroutine b64_encode_I2 ( n , code ) !< Encode scalar number to base64 (I2P). integer ( I2P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). allocate ( nI1P ( 1 :(( BYI2P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI2P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI2P ), 3_I2P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_I2","tags":"","loc":"proc/b64_encode_i2.html","title":"b64_encode_I2 – BeFoR64"},{"text":"private pure subroutine b64_encode_I2_a(n, code) Encode array numbers to base64 (I2P). Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Calls proc~~b64_encode_i2_a~~CallsGraph proc~b64_encode_i2_a b64_encode_I2_a proc~encode_bits encode_bits proc~b64_encode_i2_a->proc~encode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i2_a~~CalledByGraph proc~b64_encode_i2_a b64_encode_I2_a proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_i2_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_i2_a proc~autotest autotest proc~autotest->interface~b64_encode program~befor64_test befor64_test program~befor64_test->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code b64_encode_I2_a Source Code pure subroutine b64_encode_I2_a ( n , code ) !< Encode array numbers to base64 (I2P). integer ( I2P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI2P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI2P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI2P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_I2_a","tags":"","loc":"proc/b64_encode_i2_a.html","title":"b64_encode_I2_a – BeFoR64"},{"text":"private pure subroutine b64_encode_I4(n, code) Encode scalar number to base64 (I4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Calls proc~~b64_encode_i4~~CallsGraph proc~b64_encode_i4 b64_encode_I4 proc~encode_bits encode_bits proc~b64_encode_i4->proc~encode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i4~~CalledByGraph proc~b64_encode_i4 b64_encode_I4 proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_i4 interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_i4 proc~autotest autotest proc~autotest->interface~b64_encode program~befor64_test befor64_test program~befor64_test->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code b64_encode_I4 Source Code pure subroutine b64_encode_I4 ( n , code ) !< Encode scalar number to base64 (I4P). integer ( I4P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). allocate ( nI1P ( 1 :(( BYI4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI4P ), 3_I4P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_I4","tags":"","loc":"proc/b64_encode_i4.html","title":"b64_encode_I4 – BeFoR64"},{"text":"private pure subroutine b64_encode_I4_a(n, code) Encode array numbers to base64 (I4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Calls proc~~b64_encode_i4_a~~CallsGraph proc~b64_encode_i4_a b64_encode_I4_a proc~encode_bits encode_bits proc~b64_encode_i4_a->proc~encode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i4_a~~CalledByGraph proc~b64_encode_i4_a b64_encode_I4_a proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_i4_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_i4_a proc~autotest autotest proc~autotest->interface~b64_encode program~befor64_test befor64_test program~befor64_test->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code b64_encode_I4_a Source Code pure subroutine b64_encode_I4_a ( n , code ) !< Encode array numbers to base64 (I4P). integer ( I4P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI4P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_I4_a","tags":"","loc":"proc/b64_encode_i4_a.html","title":"b64_encode_I4_a – BeFoR64"},{"text":"private pure subroutine b64_encode_I8(n, code) Encode scalar number to base64 (I8P). Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Calls proc~~b64_encode_i8~~CallsGraph proc~b64_encode_i8 b64_encode_I8 proc~encode_bits encode_bits proc~b64_encode_i8->proc~encode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i8~~CalledByGraph proc~b64_encode_i8 b64_encode_I8 proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_i8 interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_i8 proc~autotest autotest proc~autotest->interface~b64_encode program~befor64_test befor64_test program~befor64_test->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code b64_encode_I8 Source Code pure subroutine b64_encode_I8 ( n , code ) !< Encode scalar number to base64 (I8P). integer ( I8P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). allocate ( nI1P ( 1 :(( BYI8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYI8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYI8P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_I8","tags":"","loc":"proc/b64_encode_i8.html","title":"b64_encode_I8 – BeFoR64"},{"text":"private pure subroutine b64_encode_I8_a(n, code) Encode array numbers to base64 (I8P). Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Calls proc~~b64_encode_i8_a~~CallsGraph proc~b64_encode_i8_a b64_encode_I8_a proc~encode_bits encode_bits proc~b64_encode_i8_a->proc~encode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_i8_a~~CalledByGraph proc~b64_encode_i8_a b64_encode_I8_a proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_i8_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_i8_a proc~autotest autotest proc~autotest->interface~b64_encode program~befor64_test befor64_test program~befor64_test->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code b64_encode_I8_a Source Code pure subroutine b64_encode_I8_a ( n , code ) !< Encode array numbers to base64 (I8P). integer ( I8P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYI8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYI8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYI8P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_I8_a","tags":"","loc":"proc/b64_encode_i8_a.html","title":"b64_encode_I8_a – BeFoR64"},{"text":"private pure subroutine b64_encode_R16(n, code) Encode scalar number to base64 (R16P). Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Calls proc~~b64_encode_r16~~CallsGraph proc~b64_encode_r16 b64_encode_R16 proc~encode_bits encode_bits proc~b64_encode_r16->proc~encode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code b64_encode_R16 Source Code pure subroutine b64_encode_R16 ( n , code ) !< Encode scalar number to base64 (R16P). real ( R16P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). allocate ( nI1P ( 1 :(( BYR16P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYR16P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYR16P ), 3_I2P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_R16","tags":"","loc":"proc/b64_encode_r16.html","title":"b64_encode_R16 – BeFoR64"},{"text":"private pure subroutine b64_encode_R16_a(n, code) Encode array numbers to base64 (R16P). Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Calls proc~~b64_encode_r16_a~~CallsGraph proc~b64_encode_r16_a b64_encode_R16_a proc~encode_bits encode_bits proc~b64_encode_r16_a->proc~encode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code b64_encode_R16_a Source Code pure subroutine b64_encode_R16_a ( n , code ) !< Encode array numbers to base64 (R16P). real ( R16P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYR16P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYR16P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYR16P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_R16_a","tags":"","loc":"proc/b64_encode_r16_a.html","title":"b64_encode_R16_a – BeFoR64"},{"text":"private pure subroutine b64_encode_R4(n, code) Encode scalar number to base64 (R4P). Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Calls proc~~b64_encode_r4~~CallsGraph proc~b64_encode_r4 b64_encode_R4 proc~encode_bits encode_bits proc~b64_encode_r4->proc~encode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_r4~~CalledByGraph proc~b64_encode_r4 b64_encode_R4 proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_r4 interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_r4 proc~autotest autotest proc~autotest->interface~b64_encode program~befor64_test befor64_test program~befor64_test->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code b64_encode_R4 Source Code pure subroutine b64_encode_R4 ( n , code ) !< Encode scalar number to base64 (R4P). real ( R4P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). allocate ( nI1P ( 1 :(( BYR4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYR4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYR4P ), 3_I1P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_R4","tags":"","loc":"proc/b64_encode_r4.html","title":"b64_encode_R4 – BeFoR64"},{"text":"private pure subroutine b64_encode_R4_a(n, code) Encode array numbers to base64 (R4P). Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Calls proc~~b64_encode_r4_a~~CallsGraph proc~b64_encode_r4_a b64_encode_R4_a proc~encode_bits encode_bits proc~b64_encode_r4_a->proc~encode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_r4_a~~CalledByGraph proc~b64_encode_r4_a b64_encode_R4_a proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_r4_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_r4_a proc~autotest autotest proc~autotest->interface~b64_encode program~befor64_test befor64_test program~befor64_test->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code b64_encode_R4_a Source Code pure subroutine b64_encode_R4_a ( n , code ) !< Encode array numbers to base64 (R4P). real ( R4P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYR4P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYR4P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYR4P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_R4_a","tags":"","loc":"proc/b64_encode_r4_a.html","title":"b64_encode_R4_a – BeFoR64"},{"text":"private pure subroutine b64_encode_R8(n, code) Encode scalar number to base64 (R8P). Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Calls proc~~b64_encode_r8~~CallsGraph proc~b64_encode_r8 b64_encode_R8 proc~encode_bits encode_bits proc~b64_encode_r8->proc~encode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_r8~~CalledByGraph proc~b64_encode_r8 b64_encode_R8 proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_r8 interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_r8 proc~autotest autotest proc~autotest->interface~b64_encode program~befor64_test befor64_test program~befor64_test->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code b64_encode_R8 Source Code pure subroutine b64_encode_R8 ( n , code ) !< Encode scalar number to base64 (R8P). real ( R8P ), intent ( in ) :: n !< Number to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). allocate ( nI1P ( 1 :(( BYR8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYR8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( BYR8P ), 3_I1P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_R8","tags":"","loc":"proc/b64_encode_r8.html","title":"b64_encode_R8 – BeFoR64"},{"text":"private pure subroutine b64_encode_R8_a(n, code) Encode array numbers to base64 (R8P). Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Calls proc~~b64_encode_r8_a~~CallsGraph proc~b64_encode_r8_a b64_encode_R8_a proc~encode_bits encode_bits proc~b64_encode_r8_a->proc~encode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_r8_a~~CalledByGraph proc~b64_encode_r8_a b64_encode_R8_a proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_r8_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_r8_a proc~autotest autotest proc~autotest->interface~b64_encode program~befor64_test befor64_test program~befor64_test->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code b64_encode_R8_a Source Code pure subroutine b64_encode_R8_a ( n , code ) !< Encode array numbers to base64 (R8P). real ( R8P ), intent ( in ) :: n ( 1 :) !< Array of numbers to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I8P ) :: ns !< Size of n. ns = size ( n , dim = 1 ) allocate ( nI1P ( 1 :(( ns * BYR8P + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( ns * BYR8P + 2 ) / 3 ) * 4 ) nI1P = transfer ( n , nI1P ) padd = mod (( ns * BYR8P ), 3_I8P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_R8_a","tags":"","loc":"proc/b64_encode_r8_a.html","title":"b64_encode_R8_a – BeFoR64"},{"text":"private pure subroutine b64_encode_string(s, code) Encode scalar string to base64. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Calls proc~~b64_encode_string~~CallsGraph proc~b64_encode_string b64_encode_string byte_size byte_size proc~b64_encode_string->byte_size proc~encode_bits encode_bits proc~b64_encode_string->proc~encode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_string~~CalledByGraph proc~b64_encode_string b64_encode_string proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_string interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_string proc~autotest autotest proc~autotest->interface~b64_encode program~befor64_test befor64_test program~befor64_test->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code b64_encode_string Source Code pure subroutine b64_encode_string ( s , code ) !< Encode scalar string to base64. character ( * ), intent ( in ) :: s !< String to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I4P ) :: BYCHS !< Bytes of character string. BYCHS = byte_size ( s ) allocate ( nI1P ( 1 :(( BYCHS + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYCHS + 2 ) / 3 ) * 4 ) nI1P = transfer ( s , nI1P ) padd = mod (( BYCHS ), 3_I4P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_string","tags":"","loc":"proc/b64_encode_string.html","title":"b64_encode_string – BeFoR64"},{"text":"private pure subroutine b64_encode_string_a(s, code) Encode array string to base64. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s (1:) String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Calls proc~~b64_encode_string_a~~CallsGraph proc~b64_encode_string_a b64_encode_string_a byte_size byte_size proc~b64_encode_string_a->byte_size proc~encode_bits encode_bits proc~b64_encode_string_a->proc~encode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_string_a~~CalledByGraph proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_string_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_string_a proc~autotest autotest proc~autotest->interface~b64_encode program~befor64_test befor64_test program~befor64_test->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code b64_encode_string_a Source Code pure subroutine b64_encode_string_a ( s , code ) !< Encode array string to base64. character ( * ), intent ( in ) :: s ( 1 :) !< String to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. integer ( I1P ), allocatable :: nI1P (:) !< One byte integer array containing n. integer ( I4P ) :: padd !< Number of padding characters ('='). integer ( I4P ) :: BYCHS !< Bytes of character string. BYCHS = byte_size ( s ( 1 )) * size ( s , dim = 1 ) allocate ( nI1P ( 1 :(( BYCHS + 2 ) / 3 ) * 3 )) ; nI1P = 0_I1P code = repeat ( ' ' ,(( BYCHS + 2 ) / 3 ) * 4 ) nI1P = transfer ( s , nI1P ) padd = mod (( BYCHS ), 3_I4P ) ; if ( padd > 0_I4P ) padd = 3_I4P - padd call encode_bits ( bits = nI1P , padd = padd , code = code ) endsubroutine b64_encode_string_a","tags":"","loc":"proc/b64_encode_string_a.html","title":"b64_encode_string_a – BeFoR64"},{"text":"public subroutine b64_encode_up(up, code) Encode an unlimited polymorphic scalar to base64. Arguments Type Intent Optional Attributes Name class(*), intent(in) :: up Unlimited polymorphic variable to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. Calls proc~~b64_encode_up~~CallsGraph proc~b64_encode_up b64_encode_up proc~b64_encode_i2 b64_encode_I2 proc~b64_encode_up->proc~b64_encode_i2 proc~b64_encode_i1 b64_encode_I1 proc~b64_encode_up->proc~b64_encode_i1 proc~b64_encode_i8 b64_encode_I8 proc~b64_encode_up->proc~b64_encode_i8 proc~b64_encode_r8 b64_encode_R8 proc~b64_encode_up->proc~b64_encode_r8 proc~b64_encode_r4 b64_encode_R4 proc~b64_encode_up->proc~b64_encode_r4 proc~b64_encode_string b64_encode_string proc~b64_encode_up->proc~b64_encode_string proc~b64_encode_i4 b64_encode_I4 proc~b64_encode_up->proc~b64_encode_i4 proc~encode_bits encode_bits proc~b64_encode_i2->proc~encode_bits proc~b64_encode_i1->proc~encode_bits proc~b64_encode_i8->proc~encode_bits proc~b64_encode_r8->proc~encode_bits proc~b64_encode_r4->proc~encode_bits proc~b64_encode_string->proc~encode_bits byte_size byte_size proc~b64_encode_string->byte_size proc~b64_encode_i4->proc~encode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code b64_encode_up Source Code subroutine b64_encode_up ( up , code ) !< Encode an unlimited polymorphic scalar to base64. class ( * ), intent ( in ) :: up !< Unlimited polymorphic variable to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded scalar. select type ( up ) type is ( real ( R8P )) call b64_encode_R8 ( n = up , code = code ) type is ( real ( R4P )) call b64_encode_R4 ( n = up , code = code ) type is ( integer ( I8P )) call b64_encode_I8 ( n = up , code = code ) type is ( integer ( I4P )) call b64_encode_I4 ( n = up , code = code ) type is ( integer ( I2P )) call b64_encode_I2 ( n = up , code = code ) type is ( integer ( I1P )) call b64_encode_I1 ( n = up , code = code ) type is ( character ( * )) call b64_encode_string ( s = up , code = code ) endselect endsubroutine b64_encode_up","tags":"","loc":"proc/b64_encode_up.html","title":"b64_encode_up – BeFoR64"},{"text":"private pure subroutine b64_encode_up_a(up, code) Encode an unlimited polymorphic array to base64. Arguments Type Intent Optional Attributes Name class(*), intent(in) :: up (1:) Unlimited polymorphic variable to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Calls proc~~b64_encode_up_a~~CallsGraph proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_i1_a b64_encode_I1_a proc~b64_encode_up_a->proc~b64_encode_i1_a proc~b64_encode_r8_a b64_encode_R8_a proc~b64_encode_up_a->proc~b64_encode_r8_a proc~b64_encode_i8_a b64_encode_I8_a proc~b64_encode_up_a->proc~b64_encode_i8_a proc~b64_encode_i2_a b64_encode_I2_a proc~b64_encode_up_a->proc~b64_encode_i2_a proc~b64_encode_r4_a b64_encode_R4_a proc~b64_encode_up_a->proc~b64_encode_r4_a proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_up_a->proc~b64_encode_string_a proc~b64_encode_i4_a b64_encode_I4_a proc~b64_encode_up_a->proc~b64_encode_i4_a proc~encode_bits encode_bits proc~b64_encode_i1_a->proc~encode_bits proc~b64_encode_r8_a->proc~encode_bits proc~b64_encode_i8_a->proc~encode_bits proc~b64_encode_i2_a->proc~encode_bits proc~b64_encode_r4_a->proc~encode_bits proc~b64_encode_string_a->proc~encode_bits byte_size byte_size proc~b64_encode_string_a->byte_size proc~b64_encode_i4_a->proc~encode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~b64_encode_up_a~~CalledByGraph proc~b64_encode_up_a b64_encode_up_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code b64_encode_up_a Source Code pure subroutine b64_encode_up_a ( up , code ) !< Encode an unlimited polymorphic array to base64. class ( * ), intent ( in ) :: up ( 1 :) !< Unlimited polymorphic variable to be encoded. character ( len = :), allocatable , intent ( out ) :: code !< Encoded array. select type ( up ) type is ( real ( R8P )) call b64_encode_R8_a ( n = up , code = code ) type is ( real ( R4P )) call b64_encode_R4_a ( n = up , code = code ) type is ( integer ( I8P )) call b64_encode_I8_a ( n = up , code = code ) type is ( integer ( I4P )) call b64_encode_I4_a ( n = up , code = code ) type is ( integer ( I2P )) call b64_encode_I2_a ( n = up , code = code ) type is ( integer ( I1P )) call b64_encode_I1_a ( n = up , code = code ) type is ( character ( * )) call b64_encode_string_a ( s = up , code = code ) endselect endsubroutine b64_encode_up_a","tags":"","loc":"proc/b64_encode_up_a.html","title":"b64_encode_up_a – BeFoR64"},{"text":"public subroutine b64_init() Initialize the BeFoR64 library. Note This procedure must be called before encoding/decoding anything! Arguments None Called By proc~~b64_init~~CalledByGraph proc~b64_init b64_init proc~autotest autotest proc~autotest->proc~b64_init program~befor64_test befor64_test program~befor64_test->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code b64_init Source Code subroutine b64_init () !< Initialize the BeFoR64 library. !< !< @note This procedure **must** be called before encoding/decoding anything! if (. not . is_initialized ) call penf_init is_b64_initialized = . true . endsubroutine b64_init","tags":"","loc":"proc/b64_init.html","title":"b64_init – BeFoR64"},{"text":"private pure subroutine decode_bits(code, bits) Decode a base64 string into a sequence of bits stream. The base64 string must be parsed with a strike of 4 characters and converted into a 3 bytes stream. Considering the base64 code QUJD the decoding process must do +-b64 char--+-b64 char--+-b64 char--+-b64 char--+\n |      Q    |      U    |      J    |      D    |\n +-b64 index-+-b64 index-+-b64 index-+-b64 index-+\n !      16   |      20   |      9    |      3    |\n +-6 bits----+-6 bits----+-6 bits----+-6 bits----+\n |0 1 0 0 0 0|0 1 0 1 0 0|0 0 1 0 0 1|0 0 0 0 1 1|\n +-----------+---+-------+-------+---+-----------+\n |0 1 0 0 0 0 0 1|0 1 0 0 0 0 1 0|0 1 0 0 0 0 1 1|\n +-----8 bits----+-----8 bits----+-----8 bits----+ Note The bits pattern is returned as a 1-byte element array, the dimension of witch must be computed outside this procedure. Warning This procedure is the backend of decoding, thus it must be never called outside the module. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Characters code. integer(kind=I1P), intent(out) :: bits (1:) Bits decoded. Called By proc~~decode_bits~~CalledByGraph proc~decode_bits decode_bits proc~b64_decode_r16 b64_decode_R16 proc~b64_decode_r16->proc~decode_bits proc~b64_decode_r8 b64_decode_R8 proc~b64_decode_r8->proc~decode_bits proc~b64_decode_i1_a b64_decode_I1_a proc~b64_decode_i1_a->proc~decode_bits proc~b64_decode_i2 b64_decode_I2 proc~b64_decode_i2->proc~decode_bits proc~b64_decode_r4 b64_decode_R4 proc~b64_decode_r4->proc~decode_bits proc~b64_decode_r4_a b64_decode_R4_a proc~b64_decode_r4_a->proc~decode_bits proc~b64_decode_string b64_decode_string proc~b64_decode_string->proc~decode_bits proc~b64_decode_i8 b64_decode_I8 proc~b64_decode_i8->proc~decode_bits proc~b64_decode_r16_a b64_decode_R16_a proc~b64_decode_r16_a->proc~decode_bits proc~b64_decode_i1 b64_decode_I1 proc~b64_decode_i1->proc~decode_bits proc~b64_decode_i8_a b64_decode_I8_a proc~b64_decode_i8_a->proc~decode_bits proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_string_a->proc~decode_bits proc~b64_decode_i4 b64_decode_I4 proc~b64_decode_i4->proc~decode_bits proc~b64_decode_i2_a b64_decode_I2_a proc~b64_decode_i2_a->proc~decode_bits proc~b64_decode_r8_a b64_decode_R8_a proc~b64_decode_r8_a->proc~decode_bits proc~b64_decode_i4_a b64_decode_I4_a proc~b64_decode_i4_a->proc~decode_bits proc~b64_decode_up b64_decode_up proc~b64_decode_up->proc~b64_decode_r8 proc~b64_decode_up->proc~b64_decode_i2 proc~b64_decode_up->proc~b64_decode_r4 proc~b64_decode_up->proc~b64_decode_string proc~b64_decode_up->proc~b64_decode_i8 proc~b64_decode_up->proc~b64_decode_i1 proc~b64_decode_up->proc~b64_decode_i4 interface~b64_decode b64_decode interface~b64_decode->proc~b64_decode_r8 interface~b64_decode->proc~b64_decode_i1_a interface~b64_decode->proc~b64_decode_i2 interface~b64_decode->proc~b64_decode_r4 interface~b64_decode->proc~b64_decode_r4_a interface~b64_decode->proc~b64_decode_string interface~b64_decode->proc~b64_decode_i8 interface~b64_decode->proc~b64_decode_i1 interface~b64_decode->proc~b64_decode_i8_a interface~b64_decode->proc~b64_decode_string_a interface~b64_decode->proc~b64_decode_i4 interface~b64_decode->proc~b64_decode_i2_a interface~b64_decode->proc~b64_decode_r8_a interface~b64_decode->proc~b64_decode_i4_a proc~autotest autotest proc~autotest->interface~b64_decode program~befor64_test befor64_test program~befor64_test->proc~autotest proc~b64_decode_up_a b64_decode_up_a proc~b64_decode_up_a->proc~b64_decode_i1_a proc~b64_decode_up_a->proc~b64_decode_r4_a proc~b64_decode_up_a->proc~b64_decode_i8_a proc~b64_decode_up_a->proc~b64_decode_string_a proc~b64_decode_up_a->proc~b64_decode_i2_a proc~b64_decode_up_a->proc~b64_decode_r8_a proc~b64_decode_up_a->proc~b64_decode_i4_a interface~b64_decode_up b64_decode_up interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a interface~b64_decode_up->interface~b64_decode_up Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code decode_bits Source Code pure subroutine decode_bits ( code , bits ) !< Decode a base64 string into a sequence of bits stream. !< !< The base64 string must be parsed with a strike of 4 characters and converted into a 3 bytes stream. Considering the base64 code !< `QUJD` the decoding process must do !<``` !< +-b64 char--+-b64 char--+-b64 char--+-b64 char--+ !< |      Q    |      U    |      J    |      D    | !< +-b64 index-+-b64 index-+-b64 index-+-b64 index-+ !< !      16   |      20   |      9    |      3    | !< +-6 bits----+-6 bits----+-6 bits----+-6 bits----+ !< |0 1 0 0 0 0|0 1 0 1 0 0|0 0 1 0 0 1|0 0 0 0 1 1| !< +-----------+---+-------+-------+---+-----------+ !< |0 1 0 0 0 0 0 1|0 1 0 0 0 0 1 0|0 1 0 0 0 0 1 1| !< +-----8 bits----+-----8 bits----+-----8 bits----+ !<``` !< @note The bits pattern is returned as a 1-byte element array, the dimension of witch must be computed outside this procedure. !< !< @warning This procedure is the backend of decoding, thus it must be never called outside the module. character ( * ), intent ( in ) :: code !< Characters code. integer ( I1P ), intent ( out ) :: bits ( 1 :) !< Bits decoded. integer ( I1P ) :: sixb ( 1 : 4 ) !< 6 bits slices (stored into 8 bits integer) of 24 bits input. integer ( I8P ) :: c !< Counter. integer ( I8P ) :: e !< Counter. integer ( I8P ) :: Nb !< Length of bits array. Nb = size ( bits , dim = 1 , kind = I8P ) e = 1_I8P do c = 1_I8P , len ( code ), 4_I8P ! loop over code characters: 3 bytes (24 bits) scanning sixb = 0_I1P sixb ( 1 ) = index ( base64 , code ( c : c )) - 1 sixb ( 2 ) = index ( base64 , code ( c + 1 : c + 1 )) - 1 sixb ( 3 ) = index ( base64 , code ( c + 2 : c + 2 )) - 1 sixb ( 4 ) = index ( base64 , code ( c + 3 : c + 3 )) - 1 call mvbits ( sixb ( 1 ), 0 , 6 , bits ( e ), 2 ) ; call mvbits ( sixb ( 2 ), 4 , 2 , bits ( e ), 0 ) if ( e + 1 <= Nb ) then call mvbits ( sixb ( 2 ), 0 , 4 , bits ( e + 1 ), 4 ) ; call mvbits ( sixb ( 3 ), 2 , 4 , bits ( e + 1 ), 0 ) endif if ( e + 2 <= Nb ) then call mvbits ( sixb ( 3 ), 0 , 2 , bits ( e + 2 ), 6 ) ; call mvbits ( sixb ( 4 ), 0 , 6 , bits ( e + 2 ), 0 ) endif e = e + 3_I8P enddo endsubroutine decode_bits","tags":"","loc":"proc/decode_bits.html","title":"decode_bits – BeFoR64"},{"text":"private pure subroutine encode_bits(bits, padd, code) Encode a bits stream (must be multiple of 24 bits) into base64 charcaters code (of length multiple of 4). The bits stream are encoded in chunks of 24 bits as the following example (in little endian order) +--first octet--+-second octet--+--third octet--+\n |7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|\n +-----------+---+-------+-------+---+-----------+\n |5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0|\n +--1.index--+--2.index--+--3.index--+--4.index--+ Note The 4 indexes are stored into 4 elements 8 bits array, thus 2 bits of each array element are not used. Note The number of paddings must be computed outside this procedure, into the calling scope. Warning This procedure is the backend of encoding, thus it must be never called outside the module. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: bits (1:) Bits to be encoded. integer(kind=I4P), intent(in) :: padd Number of padding characters ('='). character(len=*), intent(out) :: code Characters code. Called By proc~~encode_bits~~CalledByGraph proc~encode_bits encode_bits proc~b64_encode_i1 b64_encode_I1 proc~b64_encode_i1->proc~encode_bits proc~b64_encode_i4 b64_encode_I4 proc~b64_encode_i4->proc~encode_bits proc~b64_encode_string b64_encode_string proc~b64_encode_string->proc~encode_bits proc~b64_encode_i2_a b64_encode_I2_a proc~b64_encode_i2_a->proc~encode_bits proc~b64_encode_i8 b64_encode_I8 proc~b64_encode_i8->proc~encode_bits proc~b64_encode_r8_a b64_encode_R8_a proc~b64_encode_r8_a->proc~encode_bits proc~b64_encode_i4_a b64_encode_I4_a proc~b64_encode_i4_a->proc~encode_bits proc~b64_encode_r8 b64_encode_R8 proc~b64_encode_r8->proc~encode_bits proc~b64_encode_r16 b64_encode_R16 proc~b64_encode_r16->proc~encode_bits proc~b64_encode_i1_a b64_encode_I1_a proc~b64_encode_i1_a->proc~encode_bits proc~b64_encode_r4_a b64_encode_R4_a proc~b64_encode_r4_a->proc~encode_bits proc~b64_encode_r4 b64_encode_R4 proc~b64_encode_r4->proc~encode_bits proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_string_a->proc~encode_bits proc~b64_encode_r16_a b64_encode_R16_a proc~b64_encode_r16_a->proc~encode_bits proc~b64_encode_i8_a b64_encode_I8_a proc~b64_encode_i8_a->proc~encode_bits proc~b64_encode_i2 b64_encode_I2 proc~b64_encode_i2->proc~encode_bits proc~b64_encode_up b64_encode_up proc~b64_encode_up->proc~b64_encode_i1 proc~b64_encode_up->proc~b64_encode_i4 proc~b64_encode_up->proc~b64_encode_string proc~b64_encode_up->proc~b64_encode_i8 proc~b64_encode_up->proc~b64_encode_r8 proc~b64_encode_up->proc~b64_encode_r4 proc~b64_encode_up->proc~b64_encode_i2 interface~b64_encode b64_encode interface~b64_encode->proc~b64_encode_i1 interface~b64_encode->proc~b64_encode_i4 interface~b64_encode->proc~b64_encode_string interface~b64_encode->proc~b64_encode_i2_a interface~b64_encode->proc~b64_encode_i8 interface~b64_encode->proc~b64_encode_r8_a interface~b64_encode->proc~b64_encode_i4_a interface~b64_encode->proc~b64_encode_r8 interface~b64_encode->proc~b64_encode_i1_a interface~b64_encode->proc~b64_encode_r4_a interface~b64_encode->proc~b64_encode_r4 interface~b64_encode->proc~b64_encode_string_a interface~b64_encode->proc~b64_encode_i8_a interface~b64_encode->proc~b64_encode_i2 proc~autotest autotest proc~autotest->interface~b64_encode program~befor64_test befor64_test program~befor64_test->proc~autotest proc~b64_encode_up_a b64_encode_up_a proc~b64_encode_up_a->proc~b64_encode_i2_a proc~b64_encode_up_a->proc~b64_encode_r8_a proc~b64_encode_up_a->proc~b64_encode_i4_a proc~b64_encode_up_a->proc~b64_encode_i1_a proc~b64_encode_up_a->proc~b64_encode_r4_a proc~b64_encode_up_a->proc~b64_encode_string_a proc~b64_encode_up_a->proc~b64_encode_i8_a interface~b64_encode_up b64_encode_up interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a interface~b64_encode_up->interface~b64_encode_up Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code encode_bits Source Code pure subroutine encode_bits ( bits , padd , code ) !< Encode a bits stream (must be multiple of 24 bits) into base64 charcaters code (of length multiple of 4). !< !< The bits stream are encoded in chunks of 24 bits as the following example (in little endian order) !<``` !< +--first octet--+-second octet--+--third octet--+ !< |7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0| !< +-----------+---+-------+-------+---+-----------+ !< |5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0|5 4 3 2 1 0| !< +--1.index--+--2.index--+--3.index--+--4.index--+ !<``` !< @note The 4 indexes are stored into 4 elements 8 bits array, thus 2 bits of each array element are not used. !< !< @note The number of paddings must be computed outside this procedure, into the calling scope. !< !< @warning This procedure is the backend of encoding, thus it must be never called outside the module. integer ( I1P ), intent ( in ) :: bits ( 1 :) !< Bits to be encoded. integer ( I4P ), intent ( in ) :: padd !< Number of padding characters ('='). character ( * ), intent ( out ) :: code !< Characters code. integer ( I1P ) :: sixb ( 1 : 4 ) !< 6 bits slices (stored into 8 bits integer) of 24 bits input. integer ( I8P ) :: c !< Counter. integer ( I8P ) :: e !< Counter. integer ( I8P ) :: Nb !< Length of bits array. Nb = size ( bits , dim = 1 , kind = I8P ) c = 1_I8P do e = 1_I8P , Nb , 3_I8P ! loop over array elements: 3 bytes (24 bits) scanning sixb = 0_I1P call mvbits ( bits ( e ), 2 , 6 , sixb ( 1 ), 0 ) call mvbits ( bits ( e ), 0 , 2 , sixb ( 2 ), 4 ) if ( e + 1 <= Nb ) then call mvbits ( bits ( e + 1 ), 4 , 4 , sixb ( 2 ), 0 ) call mvbits ( bits ( e + 1 ), 0 , 4 , sixb ( 3 ), 2 ) endif if ( e + 2 <= Nb ) then call mvbits ( bits ( e + 2 ), 6 , 2 , sixb ( 3 ), 0 ) call mvbits ( bits ( e + 2 ), 0 , 6 , sixb ( 4 ), 0 ) endif sixb = sixb + 1_I1P code ( c : c ) = base64 ( sixb ( 1 ): sixb ( 1 )) code ( c + 1 : c + 1 ) = base64 ( sixb ( 2 ): sixb ( 2 )) code ( c + 2 : c + 2 ) = base64 ( sixb ( 3 ): sixb ( 3 )) code ( c + 3 : c + 3 ) = base64 ( sixb ( 4 ): sixb ( 4 )) c = c + 4_I8P enddo if ( padd > 0 ) code ( len ( code ) - padd + 1 :) = repeat ( '=' , padd ) endsubroutine encode_bits","tags":"","loc":"proc/encode_bits.html","title":"encode_bits – BeFoR64"},{"text":"public interface b64_decode Decode numbers (integer and real) from base64. This is an interface for decoding integer and real numbers of any kinds from a base64 string. This interface can decode both\n scalar and array. Note Before start to decode anything the library must be initialized. The procedure b64_init must be called at first. The\n global variable is_b64_initialized can be used to check the status of the initialization. Usage For a practical example see the autotest procedure. Scalar decoding real ( R8P ) :: decoded ! scalar to be decoded ... call b64_decode ( code = 'AAAAAAAA8D8=' , n = decoded ) Array decoding integer ( I8P ) :: decoded ( 1 : 4 ) ! array to be decoded ... call b64_decode ( code = 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' , n = decoded ) Note If you want to decode heterogenous data (e.g. integer and real numbers), you must use the auxiliary pack_data procedure. Warning The decoding of array of strings is admitted only if each string of the array has the same length. Calls interface~~b64_decode~~CallsGraph interface~b64_decode b64_decode proc~b64_decode_r8 b64_decode_R8 interface~b64_decode->proc~b64_decode_r8 proc~b64_decode_i1_a b64_decode_I1_a interface~b64_decode->proc~b64_decode_i1_a proc~b64_decode_i2 b64_decode_I2 interface~b64_decode->proc~b64_decode_i2 proc~b64_decode_r4 b64_decode_R4 interface~b64_decode->proc~b64_decode_r4 proc~b64_decode_r4_a b64_decode_R4_a interface~b64_decode->proc~b64_decode_r4_a proc~b64_decode_string b64_decode_string interface~b64_decode->proc~b64_decode_string proc~b64_decode_i8 b64_decode_I8 interface~b64_decode->proc~b64_decode_i8 proc~b64_decode_i1 b64_decode_I1 interface~b64_decode->proc~b64_decode_i1 proc~b64_decode_i8_a b64_decode_I8_a interface~b64_decode->proc~b64_decode_i8_a proc~b64_decode_string_a b64_decode_string_a interface~b64_decode->proc~b64_decode_string_a proc~b64_decode_i4 b64_decode_I4 interface~b64_decode->proc~b64_decode_i4 proc~b64_decode_i2_a b64_decode_I2_a interface~b64_decode->proc~b64_decode_i2_a proc~b64_decode_r8_a b64_decode_R8_a interface~b64_decode->proc~b64_decode_r8_a proc~b64_decode_i4_a b64_decode_I4_a interface~b64_decode->proc~b64_decode_i4_a proc~decode_bits decode_bits proc~b64_decode_r8->proc~decode_bits proc~b64_decode_i1_a->proc~decode_bits proc~b64_decode_i2->proc~decode_bits proc~b64_decode_r4->proc~decode_bits proc~b64_decode_r4_a->proc~decode_bits proc~b64_decode_string->proc~decode_bits byte_size byte_size proc~b64_decode_string->byte_size proc~b64_decode_i8->proc~decode_bits proc~b64_decode_i1->proc~decode_bits proc~b64_decode_i8_a->proc~decode_bits proc~b64_decode_string_a->proc~decode_bits proc~b64_decode_string_a->byte_size proc~b64_decode_i4->proc~decode_bits proc~b64_decode_i2_a->proc~decode_bits proc~b64_decode_r8_a->proc~decode_bits proc~b64_decode_i4_a->proc~decode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By interface~~b64_decode~~CalledByGraph interface~b64_decode b64_decode proc~autotest autotest proc~autotest->interface~b64_decode program~befor64_test befor64_test program~befor64_test->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures b64_decode_R8 b64_decode_R8_a b64_decode_R4 b64_decode_R4_a b64_decode_I8 b64_decode_I8_a b64_decode_I4 b64_decode_I4_a b64_decode_I2 b64_decode_I2_a b64_decode_I1 b64_decode_I1_a b64_decode_string b64_decode_string_a Module Procedures private elemental subroutine b64_decode_R8 (code, n) Decode a base64 code into a scalar number (R8P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R8P), intent(out) :: n Number to be decoded. private pure subroutine b64_decode_R8_a (code, n) Decode a base64 code into an array numbers (R8P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R8P), intent(out) :: n (1:) Array of numbers to be decoded. private elemental subroutine b64_decode_R4 (code, n) Decode a base64 code into a scalar number (R4P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R4P), intent(out) :: n Number to be decoded. private pure subroutine b64_decode_R4_a (code, n) Decode a base64 code into an array numbers (R4P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R4P), intent(out) :: n (1:) Array of numbers to be decoded. private elemental subroutine b64_decode_I8 (code, n) Decode a base64 code into a scalar number (I8P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I8P), intent(out) :: n Number to be decoded. private pure subroutine b64_decode_I8_a (code, n) Decode a base64 code into an array numbers (I8P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I8P), intent(out) :: n (1:) Array of numbers to be decoded. private elemental subroutine b64_decode_I4 (code, n) Decode a base64 code into a scalar number (I4P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I4P), intent(out) :: n Number to be decoded. private pure subroutine b64_decode_I4_a (code, n) Decode a base64 code into an array numbers (I4P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I4P), intent(out) :: n (1:) Array of numbers to be decoded. private elemental subroutine b64_decode_I2 (code, n) Decode a base64 code into a scalar number (I2P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I2P), intent(out) :: n Number to be decoded. private pure subroutine b64_decode_I2_a (code, n) Decode a base64 code into an array numbers (I2P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I2P), intent(out) :: n (1:) Array of numbers to be decoded. private elemental subroutine b64_decode_I1 (code, n) Decode a base64 code into a scalar number (I1P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I1P), intent(out) :: n Number to be decoded. private pure subroutine b64_decode_I1_a (code, n) Decode a base64 code into an array numbers (I1P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I1P), intent(out) :: n (1:) Array of numbers to be decoded. private elemental subroutine b64_decode_string (code, s) Decode a base64 code into a scalar string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s String to be decoded. private pure subroutine b64_decode_string_a (code, s) Decode a base64 code into an array of strings. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s (1:) String to be decoded.","tags":"","loc":"interface/b64_decode.html","title":"b64_decode – BeFoR64"},{"text":"private interface b64_decode_up Decode unlimited polymorphic variable from base64. This is an interface for decoding both scalar and array. Note Before start to decode anything the library must be initialized. The procedure b64_init must be called at first. The\n global variable is_b64_initialized can be used to check the status of the initialization. Usage For a practical example see the autotest procedure. Scalar decoding real ( R8P ) :: decoded ! scalar to be decoded ... call b64_decode_up ( code = 'AAAAAAAA8D8=' , up = decoded ) Array decoding integer ( I8P ) :: decoded ( 1 : 4 ) ! array to be decoded ... call b64_decode_up ( code = 'FwAAAAAAAABEAQAAAAAAABBwhAEAAAAAAgAAAAAAAAA=' , up = decoded ) Note If you want to decode heterogenous data (e.g. integer and real numbers), you must use the auxiliary pack_data procedure. Warning The decoding of array of strings is admitted only if each string of the array has the same length. Calls interface~~b64_decode_up~~CallsGraph interface~b64_decode_up b64_decode_up interface~b64_decode_up->interface~b64_decode_up proc~b64_decode_up_a b64_decode_up_a interface~b64_decode_up->proc~b64_decode_up_a proc~b64_decode_r4_a b64_decode_R4_a proc~b64_decode_up_a->proc~b64_decode_r4_a proc~b64_decode_i1_a b64_decode_I1_a proc~b64_decode_up_a->proc~b64_decode_i1_a proc~b64_decode_string_a b64_decode_string_a proc~b64_decode_up_a->proc~b64_decode_string_a proc~b64_decode_i8_a b64_decode_I8_a proc~b64_decode_up_a->proc~b64_decode_i8_a proc~b64_decode_i4_a b64_decode_I4_a proc~b64_decode_up_a->proc~b64_decode_i4_a proc~b64_decode_i2_a b64_decode_I2_a proc~b64_decode_up_a->proc~b64_decode_i2_a proc~b64_decode_r8_a b64_decode_R8_a proc~b64_decode_up_a->proc~b64_decode_r8_a proc~decode_bits decode_bits proc~b64_decode_r4_a->proc~decode_bits proc~b64_decode_i1_a->proc~decode_bits proc~b64_decode_string_a->proc~decode_bits byte_size byte_size proc~b64_decode_string_a->byte_size proc~b64_decode_i8_a->proc~decode_bits proc~b64_decode_i4_a->proc~decode_bits proc~b64_decode_i2_a->proc~decode_bits proc~b64_decode_r8_a->proc~decode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures b64_decode_up b64_decode_up_a Module Procedures private interface b64_decode_up () Decode unlimited polymorphic variable from base64. Arguments None private subroutine b64_decode_up_a (code, up) Decode an unlimited polymorphic array from base64. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. class(*), intent(out) :: up (1:) Unlimited polymorphic variable to be decoded.","tags":"","loc":"interface/b64_decode_up.html","title":"b64_decode_up – BeFoR64"},{"text":"public interface b64_encode Encode numbers (integer and real) to base64. This is an interface for encoding integer and real numbers of any kinds into a base64 string. This interface can encode both\n scalar and array. Warning The encoded string is returned as varying length character string, character(len=:), allocatable:: string , thus the\n compiler must support such a Fortran (2003) feature. Note Before start to encode anything the library must be initialized. The procedure b64_init must be called at first. The\n global variable is_b64_initialized can be used to check the status of the initialization. Usage For a practical example see the autotest procedure. Scalar encoding character ( len = :), allocatable :: code64 ! base64 encoded string ... call b64_encode ( n = 1 2._R8P , code = code64 ) Array encoding character ( len = :), allocatable :: code64 ! base64 encoded string ... call b64_encode ( n = [ 12_I4P , 1_I4P ], code = code64 ) Note If you want to encode heterogenous data (e.g. integer and real numbers), you must use the auxiliary pack_data procedure. Warning The encoding of array of strings is admitted only if each string of the array has the same length. Calls interface~~b64_encode~~CallsGraph interface~b64_encode b64_encode proc~b64_encode_i1 b64_encode_I1 interface~b64_encode->proc~b64_encode_i1 proc~b64_encode_i4 b64_encode_I4 interface~b64_encode->proc~b64_encode_i4 proc~b64_encode_string b64_encode_string interface~b64_encode->proc~b64_encode_string proc~b64_encode_i2_a b64_encode_I2_a interface~b64_encode->proc~b64_encode_i2_a proc~b64_encode_i8 b64_encode_I8 interface~b64_encode->proc~b64_encode_i8 proc~b64_encode_r8_a b64_encode_R8_a interface~b64_encode->proc~b64_encode_r8_a proc~b64_encode_i4_a b64_encode_I4_a interface~b64_encode->proc~b64_encode_i4_a proc~b64_encode_r8 b64_encode_R8 interface~b64_encode->proc~b64_encode_r8 proc~b64_encode_i1_a b64_encode_I1_a interface~b64_encode->proc~b64_encode_i1_a proc~b64_encode_r4_a b64_encode_R4_a interface~b64_encode->proc~b64_encode_r4_a proc~b64_encode_r4 b64_encode_R4 interface~b64_encode->proc~b64_encode_r4 proc~b64_encode_string_a b64_encode_string_a interface~b64_encode->proc~b64_encode_string_a proc~b64_encode_i8_a b64_encode_I8_a interface~b64_encode->proc~b64_encode_i8_a proc~b64_encode_i2 b64_encode_I2 interface~b64_encode->proc~b64_encode_i2 proc~encode_bits encode_bits proc~b64_encode_i1->proc~encode_bits proc~b64_encode_i4->proc~encode_bits proc~b64_encode_string->proc~encode_bits byte_size byte_size proc~b64_encode_string->byte_size proc~b64_encode_i2_a->proc~encode_bits proc~b64_encode_i8->proc~encode_bits proc~b64_encode_r8_a->proc~encode_bits proc~b64_encode_i4_a->proc~encode_bits proc~b64_encode_r8->proc~encode_bits proc~b64_encode_i1_a->proc~encode_bits proc~b64_encode_r4_a->proc~encode_bits proc~b64_encode_r4->proc~encode_bits proc~b64_encode_string_a->proc~encode_bits proc~b64_encode_string_a->byte_size proc~b64_encode_i8_a->proc~encode_bits proc~b64_encode_i2->proc~encode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By interface~~b64_encode~~CalledByGraph interface~b64_encode b64_encode proc~autotest autotest proc~autotest->interface~b64_encode program~befor64_test befor64_test program~befor64_test->proc~autotest Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures b64_encode_R8 b64_encode_R8_a b64_encode_R4 b64_encode_R4_a b64_encode_I8 b64_encode_I8_a b64_encode_I4 b64_encode_I4_a b64_encode_I2 b64_encode_I2_a b64_encode_I1 b64_encode_I1_a b64_encode_string b64_encode_string_a Module Procedures private pure subroutine b64_encode_R8 (n, code) Encode scalar number to base64 (R8P). Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. private pure subroutine b64_encode_R8_a (n, code) Encode array numbers to base64 (R8P). Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. private pure subroutine b64_encode_R4 (n, code) Encode scalar number to base64 (R4P). Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. private pure subroutine b64_encode_R4_a (n, code) Encode array numbers to base64 (R4P). Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. private pure subroutine b64_encode_I8 (n, code) Encode scalar number to base64 (I8P). Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. private pure subroutine b64_encode_I8_a (n, code) Encode array numbers to base64 (I8P). Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. private pure subroutine b64_encode_I4 (n, code) Encode scalar number to base64 (I4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. private pure subroutine b64_encode_I4_a (n, code) Encode array numbers to base64 (I4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. private pure subroutine b64_encode_I2 (n, code) Encode scalar number to base64 (I2P). Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. private pure subroutine b64_encode_I2_a (n, code) Encode array numbers to base64 (I2P). Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. private pure subroutine b64_encode_I1 (n, code) Encode scalar number to base64 (I1P). Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. private pure subroutine b64_encode_I1_a (n, code) Encode array numbers to base64 (I1P). Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. private pure subroutine b64_encode_string (s, code) Encode scalar string to base64. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. private pure subroutine b64_encode_string_a (s, code) Encode array string to base64. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s (1:) String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar.","tags":"","loc":"interface/b64_encode.html","title":"b64_encode – BeFoR64"},{"text":"private interface b64_encode_up Encode unlimited polymorphic variable to base64. This is an interface for encoding both scalar and array. Warning The encoded string is returned as varying length character string, character(len=:), allocatable:: string , thus the\n compiler must support such a Fortran (2003) feature. Note Before start to encode anything the library must be initialized. The procedure b64_init must be called at first. The\n global variable is_b64_initialized can be used to check the status of the initialization. Usage For a practical example see the autotest procedure. Scalar encoding character ( len = :), allocatable :: code64 ! base64 encoded string ... call b64_encode_up ( up = 1 2._R8P , code = code64 ) Array encoding character ( len = :), allocatable :: code64 ! base64 encoded string ... call b64_encode_up ( up = [ 12_I4P , 1_I4P ], code = code64 ) Note If you want to encode heterogenous data (e.g. integer and real numbers), you must use the auxiliary pack_data procedure. Warning The encoding of array of strings is admitted only if each string of the array has the same length. Calls interface~~b64_encode_up~~CallsGraph interface~b64_encode_up b64_encode_up interface~b64_encode_up->interface~b64_encode_up proc~b64_encode_up_a b64_encode_up_a interface~b64_encode_up->proc~b64_encode_up_a proc~b64_encode_i1_a b64_encode_I1_a proc~b64_encode_up_a->proc~b64_encode_i1_a proc~b64_encode_r8_a b64_encode_R8_a proc~b64_encode_up_a->proc~b64_encode_r8_a proc~b64_encode_i8_a b64_encode_I8_a proc~b64_encode_up_a->proc~b64_encode_i8_a proc~b64_encode_i2_a b64_encode_I2_a proc~b64_encode_up_a->proc~b64_encode_i2_a proc~b64_encode_r4_a b64_encode_R4_a proc~b64_encode_up_a->proc~b64_encode_r4_a proc~b64_encode_string_a b64_encode_string_a proc~b64_encode_up_a->proc~b64_encode_string_a proc~b64_encode_i4_a b64_encode_I4_a proc~b64_encode_up_a->proc~b64_encode_i4_a proc~encode_bits encode_bits proc~b64_encode_i1_a->proc~encode_bits proc~b64_encode_r8_a->proc~encode_bits proc~b64_encode_i8_a->proc~encode_bits proc~b64_encode_i2_a->proc~encode_bits proc~b64_encode_r4_a->proc~encode_bits proc~b64_encode_string_a->proc~encode_bits byte_size byte_size proc~b64_encode_string_a->byte_size proc~b64_encode_i4_a->proc~encode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures b64_encode_up b64_encode_up_a Module Procedures private interface b64_encode_up () Encode unlimited polymorphic variable to base64. Arguments None private pure subroutine b64_encode_up_a (up, code) Encode an unlimited polymorphic array to base64. Arguments Type Intent Optional Attributes Name class(*), intent(in) :: up (1:) Unlimited polymorphic variable to be encoded. character(len=:), intent(out), allocatable :: code Encoded array.","tags":"","loc":"interface/b64_encode_up.html","title":"b64_encode_up – BeFoR64"},{"text":"private pure subroutine pack_data_I1_I2(a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Called By proc~~pack_data_i1_i2~~CalledByGraph proc~pack_data_i1_i2 pack_data_I1_I2 interface~pack_data pack_data interface~pack_data->proc~pack_data_i1_i2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code pack_data_I1_I2 Source Code pure subroutine pack_data_I1_I2 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I1_I2","tags":"","loc":"proc/pack_data_i1_i2.html","title":"pack_data_I1_I2 – BeFoR64"},{"text":"private pure subroutine pack_data_I1_I4(a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Called By proc~~pack_data_i1_i4~~CalledByGraph proc~pack_data_i1_i4 pack_data_I1_I4 interface~pack_data pack_data interface~pack_data->proc~pack_data_i1_i4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code pack_data_I1_I4 Source Code pure subroutine pack_data_I1_I4 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I1_I4","tags":"","loc":"proc/pack_data_i1_i4.html","title":"pack_data_I1_I4 – BeFoR64"},{"text":"private pure subroutine pack_data_I1_I8(a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Called By proc~~pack_data_i1_i8~~CalledByGraph proc~pack_data_i1_i8 pack_data_I1_I8 interface~pack_data pack_data interface~pack_data->proc~pack_data_i1_i8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code pack_data_I1_I8 Source Code pure subroutine pack_data_I1_I8 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I1_I8","tags":"","loc":"proc/pack_data_i1_i8.html","title":"pack_data_I1_I8 – BeFoR64"},{"text":"private pure subroutine pack_data_I1_R4(a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Called By proc~~pack_data_i1_r4~~CalledByGraph proc~pack_data_i1_r4 pack_data_I1_R4 interface~pack_data pack_data interface~pack_data->proc~pack_data_i1_r4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code pack_data_I1_R4 Source Code pure subroutine pack_data_I1_R4 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I1_R4","tags":"","loc":"proc/pack_data_i1_r4.html","title":"pack_data_I1_R4 – BeFoR64"},{"text":"private pure subroutine pack_data_I1_R8(a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Called By proc~~pack_data_i1_r8~~CalledByGraph proc~pack_data_i1_r8 pack_data_I1_R8 interface~pack_data pack_data interface~pack_data->proc~pack_data_i1_r8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code pack_data_I1_R8 Source Code pure subroutine pack_data_I1_R8 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I1P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I1_R8","tags":"","loc":"proc/pack_data_i1_r8.html","title":"pack_data_I1_R8 – BeFoR64"},{"text":"private pure subroutine pack_data_I2_I1(a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Called By proc~~pack_data_i2_i1~~CalledByGraph proc~pack_data_i2_i1 pack_data_I2_I1 interface~pack_data pack_data interface~pack_data->proc~pack_data_i2_i1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code pack_data_I2_I1 Source Code pure subroutine pack_data_I2_I1 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I2_I1","tags":"","loc":"proc/pack_data_i2_i1.html","title":"pack_data_I2_I1 – BeFoR64"},{"text":"private pure subroutine pack_data_I2_I4(a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Called By proc~~pack_data_i2_i4~~CalledByGraph proc~pack_data_i2_i4 pack_data_I2_I4 interface~pack_data pack_data interface~pack_data->proc~pack_data_i2_i4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code pack_data_I2_I4 Source Code pure subroutine pack_data_I2_I4 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I2_I4","tags":"","loc":"proc/pack_data_i2_i4.html","title":"pack_data_I2_I4 – BeFoR64"},{"text":"private pure subroutine pack_data_I2_I8(a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Called By proc~~pack_data_i2_i8~~CalledByGraph proc~pack_data_i2_i8 pack_data_I2_I8 interface~pack_data pack_data interface~pack_data->proc~pack_data_i2_i8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code pack_data_I2_I8 Source Code pure subroutine pack_data_I2_I8 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I2_I8","tags":"","loc":"proc/pack_data_i2_i8.html","title":"pack_data_I2_I8 – BeFoR64"},{"text":"private pure subroutine pack_data_I2_R4(a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Called By proc~~pack_data_i2_r4~~CalledByGraph proc~pack_data_i2_r4 pack_data_I2_R4 interface~pack_data pack_data interface~pack_data->proc~pack_data_i2_r4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code pack_data_I2_R4 Source Code pure subroutine pack_data_I2_R4 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I2_R4","tags":"","loc":"proc/pack_data_i2_r4.html","title":"pack_data_I2_R4 – BeFoR64"},{"text":"private pure subroutine pack_data_I2_R8(a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Called By proc~~pack_data_i2_r8~~CalledByGraph proc~pack_data_i2_r8 pack_data_I2_R8 interface~pack_data pack_data interface~pack_data->proc~pack_data_i2_r8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code pack_data_I2_R8 Source Code pure subroutine pack_data_I2_R8 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I2P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I2_R8","tags":"","loc":"proc/pack_data_i2_r8.html","title":"pack_data_I2_R8 – BeFoR64"},{"text":"private pure subroutine pack_data_I4_I1(a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Called By proc~~pack_data_i4_i1~~CalledByGraph proc~pack_data_i4_i1 pack_data_I4_I1 interface~pack_data pack_data interface~pack_data->proc~pack_data_i4_i1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code pack_data_I4_I1 Source Code pure subroutine pack_data_I4_I1 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I4_I1","tags":"","loc":"proc/pack_data_i4_i1.html","title":"pack_data_I4_I1 – BeFoR64"},{"text":"private pure subroutine pack_data_I4_I2(a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Called By proc~~pack_data_i4_i2~~CalledByGraph proc~pack_data_i4_i2 pack_data_I4_I2 interface~pack_data pack_data interface~pack_data->proc~pack_data_i4_i2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code pack_data_I4_I2 Source Code pure subroutine pack_data_I4_I2 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I4_I2","tags":"","loc":"proc/pack_data_i4_i2.html","title":"pack_data_I4_I2 – BeFoR64"},{"text":"private pure subroutine pack_data_I4_I8(a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Called By proc~~pack_data_i4_i8~~CalledByGraph proc~pack_data_i4_i8 pack_data_I4_I8 interface~pack_data pack_data interface~pack_data->proc~pack_data_i4_i8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code pack_data_I4_I8 Source Code pure subroutine pack_data_I4_I8 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I4_I8","tags":"","loc":"proc/pack_data_i4_i8.html","title":"pack_data_I4_I8 – BeFoR64"},{"text":"private pure subroutine pack_data_I4_R4(a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Called By proc~~pack_data_i4_r4~~CalledByGraph proc~pack_data_i4_r4 pack_data_I4_R4 interface~pack_data pack_data interface~pack_data->proc~pack_data_i4_r4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code pack_data_I4_R4 Source Code pure subroutine pack_data_I4_R4 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I4_R4","tags":"","loc":"proc/pack_data_i4_r4.html","title":"pack_data_I4_R4 – BeFoR64"},{"text":"private pure subroutine pack_data_I4_R8(a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Called By proc~~pack_data_i4_r8~~CalledByGraph proc~pack_data_i4_r8 pack_data_I4_R8 interface~pack_data pack_data interface~pack_data->proc~pack_data_i4_r8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code pack_data_I4_R8 Source Code pure subroutine pack_data_I4_R8 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I4_R8","tags":"","loc":"proc/pack_data_i4_r8.html","title":"pack_data_I4_R8 – BeFoR64"},{"text":"private pure subroutine pack_data_I8_I1(a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Called By proc~~pack_data_i8_i1~~CalledByGraph proc~pack_data_i8_i1 pack_data_I8_I1 interface~pack_data pack_data interface~pack_data->proc~pack_data_i8_i1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code pack_data_I8_I1 Source Code pure subroutine pack_data_I8_I1 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I8_I1","tags":"","loc":"proc/pack_data_i8_i1.html","title":"pack_data_I8_I1 – BeFoR64"},{"text":"private pure subroutine pack_data_I8_I2(a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Called By proc~~pack_data_i8_i2~~CalledByGraph proc~pack_data_i8_i2 pack_data_I8_I2 interface~pack_data pack_data interface~pack_data->proc~pack_data_i8_i2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code pack_data_I8_I2 Source Code pure subroutine pack_data_I8_I2 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I8_I2","tags":"","loc":"proc/pack_data_i8_i2.html","title":"pack_data_I8_I2 – BeFoR64"},{"text":"private pure subroutine pack_data_I8_I4(a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Called By proc~~pack_data_i8_i4~~CalledByGraph proc~pack_data_i8_i4 pack_data_I8_I4 interface~pack_data pack_data interface~pack_data->proc~pack_data_i8_i4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code pack_data_I8_I4 Source Code pure subroutine pack_data_I8_I4 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I8_I4","tags":"","loc":"proc/pack_data_i8_i4.html","title":"pack_data_I8_I4 – BeFoR64"},{"text":"private pure subroutine pack_data_I8_R4(a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Called By proc~~pack_data_i8_r4~~CalledByGraph proc~pack_data_i8_r4 pack_data_I8_R4 interface~pack_data pack_data interface~pack_data->proc~pack_data_i8_r4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code pack_data_I8_R4 Source Code pure subroutine pack_data_I8_R4 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I8_R4","tags":"","loc":"proc/pack_data_i8_r4.html","title":"pack_data_I8_R4 – BeFoR64"},{"text":"private pure subroutine pack_data_I8_R8(a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Called By proc~~pack_data_i8_r8~~CalledByGraph proc~pack_data_i8_r8 pack_data_I8_R8 interface~pack_data pack_data interface~pack_data->proc~pack_data_i8_r8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code pack_data_I8_R8 Source Code pure subroutine pack_data_I8_R8 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. integer ( I8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_I8_R8","tags":"","loc":"proc/pack_data_i8_r8.html","title":"pack_data_I8_R8 – BeFoR64"},{"text":"private pure subroutine pack_data_R4_I1(a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Called By proc~~pack_data_r4_i1~~CalledByGraph proc~pack_data_r4_i1 pack_data_R4_I1 interface~pack_data pack_data interface~pack_data->proc~pack_data_r4_i1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code pack_data_R4_I1 Source Code pure subroutine pack_data_R4_I1 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_R4_I1","tags":"","loc":"proc/pack_data_r4_i1.html","title":"pack_data_R4_I1 – BeFoR64"},{"text":"private pure subroutine pack_data_R4_I2(a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Called By proc~~pack_data_r4_i2~~CalledByGraph proc~pack_data_r4_i2 pack_data_R4_I2 interface~pack_data pack_data interface~pack_data->proc~pack_data_r4_i2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code pack_data_R4_I2 Source Code pure subroutine pack_data_R4_I2 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_R4_I2","tags":"","loc":"proc/pack_data_r4_i2.html","title":"pack_data_R4_I2 – BeFoR64"},{"text":"private pure subroutine pack_data_R4_I4(a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Called By proc~~pack_data_r4_i4~~CalledByGraph proc~pack_data_r4_i4 pack_data_R4_I4 interface~pack_data pack_data interface~pack_data->proc~pack_data_r4_i4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code pack_data_R4_I4 Source Code pure subroutine pack_data_R4_I4 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_R4_I4","tags":"","loc":"proc/pack_data_r4_i4.html","title":"pack_data_R4_I4 – BeFoR64"},{"text":"private pure subroutine pack_data_R4_I8(a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Called By proc~~pack_data_r4_i8~~CalledByGraph proc~pack_data_r4_i8 pack_data_R4_I8 interface~pack_data pack_data interface~pack_data->proc~pack_data_r4_i8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code pack_data_R4_I8 Source Code pure subroutine pack_data_R4_I8 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. real ( R4P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_R4_I8","tags":"","loc":"proc/pack_data_r4_i8.html","title":"pack_data_R4_I8 – BeFoR64"},{"text":"private pure subroutine pack_data_R4_R8(a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) Firs data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Called By proc~~pack_data_r4_r8~~CalledByGraph proc~pack_data_r4_r8 pack_data_R4_R8 interface~pack_data pack_data interface~pack_data->proc~pack_data_r4_r8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code pack_data_R4_R8 Source Code pure subroutine pack_data_R4_R8 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. real ( R4P ), intent ( in ) :: a1 ( 1 :) !< Firs data stream. real ( R8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_R4_R8","tags":"","loc":"proc/pack_data_r4_r8.html","title":"pack_data_R4_R8 – BeFoR64"},{"text":"private pure subroutine pack_data_R8_I1(a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Called By proc~~pack_data_r8_i1~~CalledByGraph proc~pack_data_r8_i1 pack_data_R8_I1 interface~pack_data pack_data interface~pack_data->proc~pack_data_r8_i1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code pack_data_R8_I1 Source Code pure subroutine pack_data_R8_I1 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I1P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_R8_I1","tags":"","loc":"proc/pack_data_r8_i1.html","title":"pack_data_R8_I1 – BeFoR64"},{"text":"private pure subroutine pack_data_R8_I2(a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Called By proc~~pack_data_r8_i2~~CalledByGraph proc~pack_data_r8_i2 pack_data_R8_I2 interface~pack_data pack_data interface~pack_data->proc~pack_data_r8_i2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code pack_data_R8_I2 Source Code pure subroutine pack_data_R8_I2 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I2P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_R8_I2","tags":"","loc":"proc/pack_data_r8_i2.html","title":"pack_data_R8_I2 – BeFoR64"},{"text":"private pure subroutine pack_data_R8_I4(a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Called By proc~~pack_data_r8_i4~~CalledByGraph proc~pack_data_r8_i4 pack_data_R8_I4 interface~pack_data pack_data interface~pack_data->proc~pack_data_r8_i4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code pack_data_R8_I4 Source Code pure subroutine pack_data_R8_I4 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_R8_I4","tags":"","loc":"proc/pack_data_r8_i4.html","title":"pack_data_R8_I4 – BeFoR64"},{"text":"private pure subroutine pack_data_R8_I8(a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Called By proc~~pack_data_r8_i8~~CalledByGraph proc~pack_data_r8_i8 pack_data_R8_I8 interface~pack_data pack_data interface~pack_data->proc~pack_data_r8_i8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code pack_data_R8_I8 Source Code pure subroutine pack_data_R8_I8 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. real ( R8P ), intent ( in ) :: a1 ( 1 :) !< First data stream. integer ( I8P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_R8_I8","tags":"","loc":"proc/pack_data_r8_i8.html","title":"pack_data_R8_I8 – BeFoR64"},{"text":"private pure subroutine pack_data_R8_R4(a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) Firs data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Called By proc~~pack_data_r8_r4~~CalledByGraph proc~pack_data_r8_r4 pack_data_R8_R4 interface~pack_data pack_data interface~pack_data->proc~pack_data_r8_r4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code pack_data_R8_R4 Source Code pure subroutine pack_data_R8_R4 ( a1 , a2 , packed ) !< Pack different kinds of data into single I1P array. real ( R8P ), intent ( in ) :: a1 ( 1 :) !< Firs data stream. real ( R4P ), intent ( in ) :: a2 ( 1 :) !< Second data stream. integer ( I1P ), allocatable , intent ( inout ) :: packed (:) !< Packed data into I1P array. integer ( I1P ), allocatable :: p1 (:) !< Temporary packed data of first stream. integer ( I1P ), allocatable :: p2 (:) !< Temporary packed data of second stream. p1 = transfer ( a1 , [ 0_I1P ]) p2 = transfer ( a2 , [ 0_I1P ]) packed = [ p1 , p2 ] endsubroutine pack_data_R8_R4","tags":"","loc":"proc/pack_data_r8_r4.html","title":"pack_data_R8_R4 – BeFoR64"},{"text":"public interface pack_data Pack different kinds of data into single I1P array. This is useful for encoding different (heterogeneous) kinds variables into a single (homogeneous) stream of bits. Note This procedure exploits the transfer builtin function, that from the standard (2003+) is defined as TRANSFER(SOURCE, MOLD [, SIZE]) . Data object having a physical representation identical to that of SOURCE but with the type\n and type parameters of MOLD . The result is of the same type and type parameters as MOLD .\n If MOLD is an array and SIZE is absent, the result is an array and of rank one. Its size is as small as possible such\n that its physical representation is not shorter than that of SOURCE . Presently, the following combinations are available: Arrays-Arrays: real(any)-real(any); real(any)-integer(any); integer(any)-integer(any); integer(any)-real(any); real(any)-character; character-real(any); integer(any)-character; character-integer(any); Scalars-Scalars: real(any)-real(any); real(any)-integer(any); integer(any)-integer(any); integer(any)-real(any); real(any)-character; character-real(any); integer(any)-character; character-integer(any); Examples of usage Packing two real arrays, one with kind R8P and one with R4P real ( R8P ) :: array_r8 ( 1 : 12 ) real ( R4P ) :: array_r4 ( - 1 : 5 ) integer ( I1P ), allocatable :: rpack ... call pack_data ( a1 = array_r8 , a2 = array_r4 , packed = rpack ) Packing two arrays, one real with kind R4P and one integer with I4P real ( R4P ) :: array_r4 ( 2 ) integer ( I4P ) :: array_i4 ( 0 : 2 ) integer ( I1P ), allocatable :: rpack ... call pack_data ( a1 = array_r4 , a2 = array_i4 , packed = rpack ) Calls interface~~pack_data~~CallsGraph interface~pack_data pack_data proc~pack_data_i4_r4 pack_data_I4_R4 interface~pack_data->proc~pack_data_i4_r4 proc~pack_data_i2_r4 pack_data_I2_R4 interface~pack_data->proc~pack_data_i2_r4 proc~pack_data_r4_i8 pack_data_R4_I8 interface~pack_data->proc~pack_data_r4_i8 proc~pack_data_i1_r4 pack_data_I1_R4 interface~pack_data->proc~pack_data_i1_r4 proc~pack_data_r4_r8 pack_data_R4_R8 interface~pack_data->proc~pack_data_r4_r8 proc~pack_data_r8_i1 pack_data_R8_I1 interface~pack_data->proc~pack_data_r8_i1 proc~pack_data_i4_i2 pack_data_I4_I2 interface~pack_data->proc~pack_data_i4_i2 proc~pack_data_r8_i2 pack_data_R8_I2 interface~pack_data->proc~pack_data_r8_i2 proc~pack_data_r4_i1 pack_data_R4_I1 interface~pack_data->proc~pack_data_r4_i1 proc~pack_data_r8_i8 pack_data_R8_I8 interface~pack_data->proc~pack_data_r8_i8 proc~pack_data_r8_i4 pack_data_R8_I4 interface~pack_data->proc~pack_data_r8_i4 proc~pack_data_i8_r8 pack_data_I8_R8 interface~pack_data->proc~pack_data_i8_r8 proc~pack_data_i2_r8 pack_data_I2_R8 interface~pack_data->proc~pack_data_i2_r8 proc~pack_data_i8_i2 pack_data_I8_I2 interface~pack_data->proc~pack_data_i8_i2 proc~pack_data_i8_r4 pack_data_I8_R4 interface~pack_data->proc~pack_data_i8_r4 proc~pack_data_i1_r8 pack_data_I1_R8 interface~pack_data->proc~pack_data_i1_r8 proc~pack_data_i8_i1 pack_data_I8_I1 interface~pack_data->proc~pack_data_i8_i1 proc~pack_data_i1_i8 pack_data_I1_I8 interface~pack_data->proc~pack_data_i1_i8 proc~pack_data_i4_r8 pack_data_I4_R8 interface~pack_data->proc~pack_data_i4_r8 proc~pack_data_r4_i4 pack_data_R4_I4 interface~pack_data->proc~pack_data_r4_i4 proc~pack_data_r8_r4 pack_data_R8_R4 interface~pack_data->proc~pack_data_r8_r4 proc~pack_data_i1_i2 pack_data_I1_I2 interface~pack_data->proc~pack_data_i1_i2 proc~pack_data_i4_i1 pack_data_I4_I1 interface~pack_data->proc~pack_data_i4_i1 proc~pack_data_i8_i4 pack_data_I8_I4 interface~pack_data->proc~pack_data_i8_i4 proc~pack_data_i4_i8 pack_data_I4_I8 interface~pack_data->proc~pack_data_i4_i8 proc~pack_data_r4_i2 pack_data_R4_I2 interface~pack_data->proc~pack_data_r4_i2 proc~pack_data_i1_i4 pack_data_I1_I4 interface~pack_data->proc~pack_data_i1_i4 proc~pack_data_i2_i8 pack_data_I2_I8 interface~pack_data->proc~pack_data_i2_i8 proc~pack_data_i2_i4 pack_data_I2_I4 interface~pack_data->proc~pack_data_i2_i4 proc~pack_data_i2_i1 pack_data_I2_I1 interface~pack_data->proc~pack_data_i2_i1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures pack_data_R8_R4 pack_data_R8_I8 pack_data_R8_I4 pack_data_R8_I2 pack_data_R8_I1 pack_data_R4_R8 pack_data_R4_I8 pack_data_R4_I4 pack_data_R4_I2 pack_data_R4_I1 pack_data_I8_R8 pack_data_I8_R4 pack_data_I8_I4 pack_data_I8_I2 pack_data_I8_I1 pack_data_I4_R8 pack_data_I4_R4 pack_data_I4_I8 pack_data_I4_I2 pack_data_I4_I1 pack_data_I2_R8 pack_data_I2_R4 pack_data_I2_I8 pack_data_I2_I4 pack_data_I2_I1 pack_data_I1_R8 pack_data_I1_R4 pack_data_I1_I8 pack_data_I1_I4 pack_data_I1_I2 Module Procedures private pure subroutine pack_data_R8_R4 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) Firs data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_R8_I8 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_R8_I4 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_R8_I2 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_R8_I1 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_R4_R8 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) Firs data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_R4_I8 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_R4_I4 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_R4_I2 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_R4_I1 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I8_R8 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I8_R4 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I8_I4 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I8_I2 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I8_I1 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I4_R8 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I4_R4 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I4_I8 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I4_I2 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I4_I1 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I2_R8 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I2_R4 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I2_I8 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I2_I4 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I2_I1 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I1_R8 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I1_R4 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I1_I8 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I1_I4 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I1_I2 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array.","tags":"","loc":"interface/pack_data.html","title":"pack_data – BeFoR64"},{"text":"Uses: penf befor64_pack_data_m module~~befor64~~UsesGraph module~befor64 befor64 module~befor64_pack_data_m befor64_pack_data_m module~befor64_pack_data_m->module~befor64 penf penf penf->module~befor64 penf->module~befor64_pack_data_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. BeFoR64, Base64 encoding/decoding library for FoRtran poor people. Used By module~~befor64~~UsedByGraph module~befor64 befor64 program~befor64_test befor64_test module~befor64->program~befor64_test Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables base64 is_b64_initialized Interfaces b64_decode b64_decode_up b64_encode b64_encode_up Subroutines autotest b64_decode_I1 b64_decode_I1_a b64_decode_I2 b64_decode_I2_a b64_decode_I4 b64_decode_I4_a b64_decode_I8 b64_decode_I8_a b64_decode_R16 b64_decode_R16_a b64_decode_R4 b64_decode_R4_a b64_decode_R8 b64_decode_R8_a b64_decode_string b64_decode_string_a b64_decode_up b64_decode_up_a b64_encode_I1 b64_encode_I1_a b64_encode_I2 b64_encode_I2_a b64_encode_I4 b64_encode_I4_a b64_encode_I8 b64_encode_I8_a b64_encode_R16 b64_encode_R16_a b64_encode_R4 b64_encode_R4_a b64_encode_R8 b64_encode_R8_a b64_encode_string b64_encode_string_a b64_encode_up b64_encode_up_a b64_init decode_bits encode_bits Variables Type Visibility Attributes Name Initial character(len=64), private :: base64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\" Base64 alphabet. logical, public :: is_b64_initialized = .false. Flag for checking the initialization of the library. Interfaces public interface b64_decode Decode numbers (integer and real) from base64. private elemental subroutine b64_decode_R8 (code, n) Decode a base64 code into a scalar number (R8P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R8P), intent(out) :: n Number to be decoded. private pure subroutine b64_decode_R8_a (code, n) Decode a base64 code into an array numbers (R8P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R8P), intent(out) :: n (1:) Array of numbers to be decoded. private elemental subroutine b64_decode_R4 (code, n) Decode a base64 code into a scalar number (R4P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R4P), intent(out) :: n Number to be decoded. private pure subroutine b64_decode_R4_a (code, n) Decode a base64 code into an array numbers (R4P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R4P), intent(out) :: n (1:) Array of numbers to be decoded. private elemental subroutine b64_decode_I8 (code, n) Decode a base64 code into a scalar number (I8P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I8P), intent(out) :: n Number to be decoded. private pure subroutine b64_decode_I8_a (code, n) Decode a base64 code into an array numbers (I8P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I8P), intent(out) :: n (1:) Array of numbers to be decoded. private elemental subroutine b64_decode_I4 (code, n) Decode a base64 code into a scalar number (I4P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I4P), intent(out) :: n Number to be decoded. private pure subroutine b64_decode_I4_a (code, n) Decode a base64 code into an array numbers (I4P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I4P), intent(out) :: n (1:) Array of numbers to be decoded. private elemental subroutine b64_decode_I2 (code, n) Decode a base64 code into a scalar number (I2P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I2P), intent(out) :: n Number to be decoded. private pure subroutine b64_decode_I2_a (code, n) Decode a base64 code into an array numbers (I2P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I2P), intent(out) :: n (1:) Array of numbers to be decoded. private elemental subroutine b64_decode_I1 (code, n) Decode a base64 code into a scalar number (I1P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I1P), intent(out) :: n Number to be decoded. private pure subroutine b64_decode_I1_a (code, n) Decode a base64 code into an array numbers (I1P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I1P), intent(out) :: n (1:) Array of numbers to be decoded. private elemental subroutine b64_decode_string (code, s) Decode a base64 code into a scalar string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s String to be decoded. private pure subroutine b64_decode_string_a (code, s) Decode a base64 code into an array of strings. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s (1:) String to be decoded. private interface b64_decode_up Decode unlimited polymorphic variable from base64. private interface b64_decode_up () Decode unlimited polymorphic variable from base64. Arguments None private subroutine b64_decode_up_a (code, up) Decode an unlimited polymorphic array from base64. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. class(*), intent(out) :: up (1:) Unlimited polymorphic variable to be decoded. public interface b64_encode Encode numbers (integer and real) to base64. private pure subroutine b64_encode_R8 (n, code) Encode scalar number to base64 (R8P). Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. private pure subroutine b64_encode_R8_a (n, code) Encode array numbers to base64 (R8P). Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. private pure subroutine b64_encode_R4 (n, code) Encode scalar number to base64 (R4P). Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. private pure subroutine b64_encode_R4_a (n, code) Encode array numbers to base64 (R4P). Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. private pure subroutine b64_encode_I8 (n, code) Encode scalar number to base64 (I8P). Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. private pure subroutine b64_encode_I8_a (n, code) Encode array numbers to base64 (I8P). Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. private pure subroutine b64_encode_I4 (n, code) Encode scalar number to base64 (I4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. private pure subroutine b64_encode_I4_a (n, code) Encode array numbers to base64 (I4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. private pure subroutine b64_encode_I2 (n, code) Encode scalar number to base64 (I2P). Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. private pure subroutine b64_encode_I2_a (n, code) Encode array numbers to base64 (I2P). Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. private pure subroutine b64_encode_I1 (n, code) Encode scalar number to base64 (I1P). Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. private pure subroutine b64_encode_I1_a (n, code) Encode array numbers to base64 (I1P). Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. private pure subroutine b64_encode_string (s, code) Encode scalar string to base64. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. private pure subroutine b64_encode_string_a (s, code) Encode array string to base64. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s (1:) String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. private interface b64_encode_up Encode unlimited polymorphic variable to base64. private interface b64_encode_up () Encode unlimited polymorphic variable to base64. Arguments None private pure subroutine b64_encode_up_a (up, code) Encode an unlimited polymorphic array to base64. Arguments Type Intent Optional Attributes Name class(*), intent(in) :: up (1:) Unlimited polymorphic variable to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. Subroutines public subroutine autotest () Procedure for autotesting the library functionalities. Arguments None private elemental subroutine b64_decode_I1 (code, n) Decode a base64 code into a scalar number (I1P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I1P), intent(out) :: n Number to be decoded. private pure subroutine b64_decode_I1_a (code, n) Decode a base64 code into an array numbers (I1P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I1P), intent(out) :: n (1:) Array of numbers to be decoded. private elemental subroutine b64_decode_I2 (code, n) Decode a base64 code into a scalar number (I2P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I2P), intent(out) :: n Number to be decoded. private pure subroutine b64_decode_I2_a (code, n) Decode a base64 code into an array numbers (I2P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I2P), intent(out) :: n (1:) Array of numbers to be decoded. private elemental subroutine b64_decode_I4 (code, n) Decode a base64 code into a scalar number (I4P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I4P), intent(out) :: n Number to be decoded. private pure subroutine b64_decode_I4_a (code, n) Decode a base64 code into an array numbers (I4P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I4P), intent(out) :: n (1:) Array of numbers to be decoded. private elemental subroutine b64_decode_I8 (code, n) Decode a base64 code into a scalar number (I8P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. integer(kind=I8P), intent(out) :: n Number to be decoded. private pure subroutine b64_decode_I8_a (code, n) Decode a base64 code into an array numbers (I8P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. integer(kind=I8P), intent(out) :: n (1:) Array of numbers to be decoded. private elemental subroutine b64_decode_R16 (code, n) Decode a base64 code into a scalar number (R16P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R16P), intent(out) :: n Number to be decoded. private pure subroutine b64_decode_R16_a (code, n) Decode a base64 code into an array numbers (R16P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R16P), intent(out) :: n (1:) Array of numbers to be decoded. private elemental subroutine b64_decode_R4 (code, n) Decode a base64 code into a scalar number (R4P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R4P), intent(out) :: n Number to be decoded. private pure subroutine b64_decode_R4_a (code, n) Decode a base64 code into an array numbers (R4P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R4P), intent(out) :: n (1:) Array of numbers to be decoded. private elemental subroutine b64_decode_R8 (code, n) Decode a base64 code into a scalar number (R8P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. real(kind=R8P), intent(out) :: n Number to be decoded. private pure subroutine b64_decode_R8_a (code, n) Decode a base64 code into an array numbers (R8P). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. real(kind=R8P), intent(out) :: n (1:) Array of numbers to be decoded. private elemental subroutine b64_decode_string (code, s) Decode a base64 code into a scalar string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s String to be decoded. private pure subroutine b64_decode_string_a (code, s) Decode a base64 code into an array of strings. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. character(len=*), intent(out) :: s (1:) String to be decoded. public subroutine b64_decode_up (code, up) Decode an unlimited polymorphic scalar from base64. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded scalar. class(*), intent(out) :: up Unlimited polymorphic variable to be decoded. private subroutine b64_decode_up_a (code, up) Decode an unlimited polymorphic array from base64. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Encoded array. class(*), intent(out) :: up (1:) Unlimited polymorphic variable to be decoded. private pure subroutine b64_encode_I1 (n, code) Encode scalar number to base64 (I1P). Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. private pure subroutine b64_encode_I1_a (n, code) Encode array numbers to base64 (I1P). Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. private pure subroutine b64_encode_I2 (n, code) Encode scalar number to base64 (I2P). Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. private pure subroutine b64_encode_I2_a (n, code) Encode array numbers to base64 (I2P). Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. private pure subroutine b64_encode_I4 (n, code) Encode scalar number to base64 (I4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. private pure subroutine b64_encode_I4_a (n, code) Encode array numbers to base64 (I4P). Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. private pure subroutine b64_encode_I8 (n, code) Encode scalar number to base64 (I8P). Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. private pure subroutine b64_encode_I8_a (n, code) Encode array numbers to base64 (I8P). Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. private pure subroutine b64_encode_R16 (n, code) Encode scalar number to base64 (R16P). Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. private pure subroutine b64_encode_R16_a (n, code) Encode array numbers to base64 (R16P). Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. private pure subroutine b64_encode_R4 (n, code) Encode scalar number to base64 (R4P). Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. private pure subroutine b64_encode_R4_a (n, code) Encode array numbers to base64 (R4P). Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. private pure subroutine b64_encode_R8 (n, code) Encode scalar number to base64 (R8P). Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Number to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. private pure subroutine b64_encode_R8_a (n, code) Encode array numbers to base64 (R8P). Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (1:) Array of numbers to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. private pure subroutine b64_encode_string (s, code) Encode scalar string to base64. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. private pure subroutine b64_encode_string_a (s, code) Encode array string to base64. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s (1:) String to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. public subroutine b64_encode_up (up, code) Encode an unlimited polymorphic scalar to base64. Arguments Type Intent Optional Attributes Name class(*), intent(in) :: up Unlimited polymorphic variable to be encoded. character(len=:), intent(out), allocatable :: code Encoded scalar. private pure subroutine b64_encode_up_a (up, code) Encode an unlimited polymorphic array to base64. Arguments Type Intent Optional Attributes Name class(*), intent(in) :: up (1:) Unlimited polymorphic variable to be encoded. character(len=:), intent(out), allocatable :: code Encoded array. public subroutine b64_init () Initialize the BeFoR64 library. Arguments None private pure subroutine decode_bits (code, bits) Decode a base64 string into a sequence of bits stream. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: code Characters code. integer(kind=I1P), intent(out) :: bits (1:) Bits decoded. private pure subroutine encode_bits (bits, padd, code) Encode a bits stream (must be multiple of 24 bits) into base64 charcaters code (of length multiple of 4). Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: bits (1:) Bits to be encoded. integer(kind=I4P), intent(in) :: padd Number of padding characters ('='). character(len=*), intent(out) :: code Characters code.","tags":"","loc":"module/befor64.html","title":"befor64 – BeFoR64"},{"text":"Uses: penf module~~befor64_pack_data_m~~UsesGraph module~befor64_pack_data_m befor64_pack_data_m penf penf penf->module~befor64_pack_data_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. KISS library for packing heterogeneous data into single (homogeneous) packed one. Used By module~~befor64_pack_data_m~~UsedByGraph module~befor64_pack_data_m befor64_pack_data_m module~befor64 befor64 module~befor64_pack_data_m->module~befor64 program~befor64_test befor64_test module~befor64->program~befor64_test Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces pack_data Subroutines pack_data_I1_I2 pack_data_I1_I4 pack_data_I1_I8 pack_data_I1_R4 pack_data_I1_R8 pack_data_I2_I1 pack_data_I2_I4 pack_data_I2_I8 pack_data_I2_R4 pack_data_I2_R8 pack_data_I4_I1 pack_data_I4_I2 pack_data_I4_I8 pack_data_I4_R4 pack_data_I4_R8 pack_data_I8_I1 pack_data_I8_I2 pack_data_I8_I4 pack_data_I8_R4 pack_data_I8_R8 pack_data_R4_I1 pack_data_R4_I2 pack_data_R4_I4 pack_data_R4_I8 pack_data_R4_R8 pack_data_R8_I1 pack_data_R8_I2 pack_data_R8_I4 pack_data_R8_I8 pack_data_R8_R4 Interfaces public interface pack_data Pack different kinds of data into single I1P array. private pure subroutine pack_data_R8_R4 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) Firs data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_R8_I8 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_R8_I4 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_R8_I2 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_R8_I1 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_R4_R8 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) Firs data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_R4_I8 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_R4_I4 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_R4_I2 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_R4_I1 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I8_R8 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I8_R4 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I8_I4 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I8_I2 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I8_I1 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I4_R8 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I4_R4 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I4_I8 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I4_I2 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I4_I1 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I2_R8 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I2_R4 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I2_I8 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I2_I4 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I2_I1 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I1_R8 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I1_R4 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I1_I8 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I1_I4 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I1_I2 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. Subroutines private pure subroutine pack_data_I1_I2 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I1_I4 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I1_I8 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I1_R4 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I1_R8 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I2_I1 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I2_I4 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I2_I8 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I2_R4 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I2_R8 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I4_I1 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I4_I2 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I4_I8 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I4_R4 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I4_R8 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I8_I1 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I8_I2 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I8_I4 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I8_R4 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_I8_R8 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: a1 (1:) First data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_R4_I1 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_R4_I2 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_R4_I4 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_R4_I8 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_R4_R8 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: a1 (1:) Firs data stream. real(kind=R8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_R8_I1 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I1P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_R8_I2 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I2P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_R8_I4 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_R8_I8 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) First data stream. integer(kind=I8P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array. private pure subroutine pack_data_R8_R4 (a1, a2, packed) Pack different kinds of data into single I1P array. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: a1 (1:) Firs data stream. real(kind=R4P), intent(in) :: a2 (1:) Second data stream. integer(kind=I1P), intent(inout), allocatable :: packed (:) Packed data into I1P array.","tags":"","loc":"module/befor64_pack_data_m.html","title":"befor64_pack_data_m – BeFoR64"},{"text":"Uses: befor64 program~~befor64_test~~UsesGraph program~befor64_test befor64_test module~befor64 befor64 module~befor64->program~befor64_test module~befor64_pack_data_m befor64_pack_data_m module~befor64_pack_data_m->module~befor64 penf penf penf->module~befor64 penf->module~befor64_pack_data_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Testing program for BeFoR64, Base64 encoding/decoding library for FoRtran poor men Usage ./Test_Driver Calls program~~befor64_test~~CallsGraph program~befor64_test befor64_test proc~autotest autotest program~befor64_test->proc~autotest interface~b64_encode b64_encode proc~autotest->interface~b64_encode interface~b64_decode b64_decode proc~autotest->interface~b64_decode proc~b64_init b64_init proc~autotest->proc~b64_init str str proc~autotest->str proc~b64_encode_i1 b64_encode_I1 interface~b64_encode->proc~b64_encode_i1 proc~b64_encode_i4 b64_encode_I4 interface~b64_encode->proc~b64_encode_i4 proc~b64_encode_string b64_encode_string interface~b64_encode->proc~b64_encode_string proc~b64_encode_i2_a b64_encode_I2_a interface~b64_encode->proc~b64_encode_i2_a proc~b64_encode_i8 b64_encode_I8 interface~b64_encode->proc~b64_encode_i8 proc~b64_encode_r8_a b64_encode_R8_a interface~b64_encode->proc~b64_encode_r8_a proc~b64_encode_i4_a b64_encode_I4_a interface~b64_encode->proc~b64_encode_i4_a proc~b64_encode_r8 b64_encode_R8 interface~b64_encode->proc~b64_encode_r8 proc~b64_encode_i1_a b64_encode_I1_a interface~b64_encode->proc~b64_encode_i1_a proc~b64_encode_r4_a b64_encode_R4_a interface~b64_encode->proc~b64_encode_r4_a proc~b64_encode_r4 b64_encode_R4 interface~b64_encode->proc~b64_encode_r4 proc~b64_encode_string_a b64_encode_string_a interface~b64_encode->proc~b64_encode_string_a proc~b64_encode_i8_a b64_encode_I8_a interface~b64_encode->proc~b64_encode_i8_a proc~b64_encode_i2 b64_encode_I2 interface~b64_encode->proc~b64_encode_i2 proc~b64_decode_r8 b64_decode_R8 interface~b64_decode->proc~b64_decode_r8 proc~b64_decode_i1_a b64_decode_I1_a interface~b64_decode->proc~b64_decode_i1_a proc~b64_decode_i2 b64_decode_I2 interface~b64_decode->proc~b64_decode_i2 proc~b64_decode_r4 b64_decode_R4 interface~b64_decode->proc~b64_decode_r4 proc~b64_decode_r4_a b64_decode_R4_a interface~b64_decode->proc~b64_decode_r4_a proc~b64_decode_string b64_decode_string interface~b64_decode->proc~b64_decode_string proc~b64_decode_i8 b64_decode_I8 interface~b64_decode->proc~b64_decode_i8 proc~b64_decode_i1 b64_decode_I1 interface~b64_decode->proc~b64_decode_i1 proc~b64_decode_i8_a b64_decode_I8_a interface~b64_decode->proc~b64_decode_i8_a proc~b64_decode_string_a b64_decode_string_a interface~b64_decode->proc~b64_decode_string_a proc~b64_decode_i4 b64_decode_I4 interface~b64_decode->proc~b64_decode_i4 proc~b64_decode_i2_a b64_decode_I2_a interface~b64_decode->proc~b64_decode_i2_a proc~b64_decode_r8_a b64_decode_R8_a interface~b64_decode->proc~b64_decode_r8_a proc~b64_decode_i4_a b64_decode_I4_a interface~b64_decode->proc~b64_decode_i4_a proc~encode_bits encode_bits proc~b64_encode_i1->proc~encode_bits proc~b64_encode_i4->proc~encode_bits proc~b64_encode_string->proc~encode_bits byte_size byte_size proc~b64_encode_string->byte_size proc~b64_encode_i2_a->proc~encode_bits proc~b64_encode_i8->proc~encode_bits proc~b64_encode_r8_a->proc~encode_bits proc~b64_encode_i4_a->proc~encode_bits proc~b64_encode_r8->proc~encode_bits proc~b64_encode_i1_a->proc~encode_bits proc~b64_encode_r4_a->proc~encode_bits proc~b64_encode_r4->proc~encode_bits proc~b64_encode_string_a->proc~encode_bits proc~b64_encode_string_a->byte_size proc~b64_encode_i8_a->proc~encode_bits proc~b64_encode_i2->proc~encode_bits proc~decode_bits decode_bits proc~b64_decode_r8->proc~decode_bits proc~b64_decode_i1_a->proc~decode_bits proc~b64_decode_i2->proc~decode_bits proc~b64_decode_r4->proc~decode_bits proc~b64_decode_r4_a->proc~decode_bits proc~b64_decode_string->byte_size proc~b64_decode_string->proc~decode_bits proc~b64_decode_i8->proc~decode_bits proc~b64_decode_i1->proc~decode_bits proc~b64_decode_i8_a->proc~decode_bits proc~b64_decode_string_a->byte_size proc~b64_decode_string_a->proc~decode_bits proc~b64_decode_i4->proc~decode_bits proc~b64_decode_i2_a->proc~decode_bits proc~b64_decode_r8_a->proc~decode_bits proc~b64_decode_i4_a->proc~decode_bits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code befor64_test Source Code program befor64_test !< Testing program for BeFoR64, Base64 encoding/decoding library for FoRtran poor men !< !<### Usage !<```bash !< ./Test_Driver !<``` use befor64 , only : autotest ! Autotesting procedure. implicit none call autotest endprogram befor64_test","tags":"","loc":"program/befor64_test.html","title":"befor64_test – BeFoR64"}]}